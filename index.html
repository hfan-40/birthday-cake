<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rose Gold Celebration Pro</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: #fff; font-family: 'Times New Roman', serif; }
        #webcam-preview { position: absolute; bottom: 10px; right: 10px; width: 140px; height: 105px; border: 1px solid #d4af37; z-index: 100; transform: scaleX(-1); border-radius: 8px; }
        #ui-layer { position: absolute; top: 20px; width: 100%; text-align: center; z-index: 10; pointer-events: none; }
        h1 { color: #d4af37; font-size: 2.5rem; letter-spacing: 5px; text-shadow: 0 0 20px rgba(212,175,55,0.5); margin: 0; }
        .hint { font-size: 0.8rem; color: #aaa; margin-top: 10px; text-transform: uppercase; }
        #loader { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; transition: opacity 0.5s; }
        .spinner { width: 40px; height: 40px; border: 2px solid #333; border-top-color: #d4af37; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <p id="load-status" style="color:#d4af37; margin-top:20px;">æ­£åœ¨ç‚¹ç‡ƒé­”æ³•...</p>
    </div>
    <div id="ui-layer">
        <h1 id="main-title">Grand Celebration</h1>
        <p class="hint">ğŸ– æ‘Šæ‰‹ï¼šç»½æ”¾ | âœŠ æ¡æ‹³ï¼šé‡èš | ğŸ˜— å˜Ÿå˜´ï¼šè®¸æ„¿å¹æ°”</p>
    </div>
    <video id="webcam" style="display:none;" autoplay playsinline></video>
    <canvas id="webcam-preview"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';

        let scene, camera, renderer, composer, particles;
        let handLandmarker, faceLandmarker, video;
        let particleCount = 4000;
        let positions = { cake: [], scatter: [], text: [] };
        let state = { mode: 'CAKE', isBlown: false, handX: 0 };
        let clock = new THREE.Clock();

        async function init() {
            try {
                initThree();
                generateShapes();
                await initAI();
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').remove(), 500);
                animate();
            } catch (e) {
                console.error(e);
                document.getElementById('load-status').innerText = "åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™æˆ–åˆ·æ–°";
            }
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // ç²’å­ç³»ç»Ÿ
            const geo = new THREE.BufferGeometry();
            const posArray = new Float32Array(particleCount * 3);
            const colorArray = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount; i++) {
                posArray[i*3] = (Math.random()-0.5)*100;
                posArray[i*3+1] = (Math.random()-0.5)*100;
                posArray[i*3+2] = (Math.random()-0.5)*100;
                
                const color = new THREE.Color(i % 2 === 0 ? 0xffb7c5 : 0xd4af37);
                colorArray[i*3] = color.r;
                colorArray[i*3+1] = color.g;
                colorArray[i*3+2] = color.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            
            const mat = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        function generateShapes() {
            // 1. è›‹ç³•å½¢æ€
            for(let i=0; i<particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                if(i < particleCount * 0.6) {
                    const r = 8 + Math.random() * 1.5;
                    positions.cake.push(Math.cos(angle)*r, Math.random()*7-3.5, Math.sin(angle)*r);
                } else {
                    const r = 5 + Math.random() * 1.2;
                    positions.cake.push(Math.cos(angle)*r, Math.random()*5+3.5, Math.sin(angle)*r);
                }
                positions.scatter.push((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
            }

            // 2. æ–‡å­—å½¢æ€ (Happy Birthday)
            const canvas = document.createElement('canvas');
            canvas.width = 400; canvas.height = 100;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 45px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('HAPPY BDAY', 200, 65);
            const imgData = ctx.getImageData(0,0,400,100).data;
            const textCoords = [];
            for(let y=0; y<100; y+=2) {
                for(let x=0; x<400; x+=2) {
                    if(imgData[(y*400+x)*4] > 128) textCoords.push({x: (x-200)*0.15, y: (50-y)*0.15 + 10});
                }
            }
            for(let i=0; i<particleCount; i++) {
                const target = textCoords[i % textCoords.length];
                positions.text.push(target.x, target.y, (Math.random()-0.5)*2);
            }
        }

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            
            // åˆ†å¼€åŠ è½½é¿å…èµ„æºé”
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });

            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", outputFaceBlendshapes: true
            });

            video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            
            // é¢„è§ˆå°çª—è®¾ç½®
            const previewCanvas = document.getElementById('webcam-preview');
            const pCtx = previewCanvas.getContext('2d');
            video.onloadedmetadata = () => {
                previewCanvas.width = video.videoWidth;
                previewCanvas.height = video.videoHeight;
            };
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = performance.now();

            if (video.readyState >= 2) {
                const handRes = handLandmarker.detectForVideo(video, time);
                if(handRes.landmarks.length > 0) {
                    const lm = handRes.landmarks[0];
                    const spread = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    if(!state.isBlown) state.mode = spread > 0.4 ? 'SCATTER' : 'CAKE';
                    state.handX = THREE.MathUtils.lerp(state.handX, (lm[9].x - 0.5) * 5, 0.1);
                }

                const faceRes = faceLandmarker.detectForVideo(video, time);
                if(faceRes.faceBlendshapes.length > 0) {
                    const pucker = faceRes.faceBlendshapes[0].categories.find(c => c.categoryName === 'mouthPucker').score;
                    if(pucker > 0.45 && !state.isBlown) {
                        state.isBlown = true;
                        state.mode = 'TEXT';
                        document.getElementById('main-title').innerText = "Make A Wish!";
                    }
                }
            }

            // æ›´æ–°ç²’å­ä½ç½®
            const posAttr = particles.geometry.attributes.position;
            const targetSet = positions[state.mode.toLowerCase()];
            for(let i=0; i<particleCount; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                posAttr.array[ix] += (targetSet[ix] - posAttr.array[ix]) * 0.1;
                posAttr.array[iy] += (targetSet[iy] - posAttr.array[iy]) * 0.1;
                posAttr.array[iz] += (targetSet[iz] - posAttr.array[iz]) * 0.1;
                
                // å¹æ•£åçš„å¾®åŠ¨
                if(state.isBlown) {
                    posAttr.array[iy] += Math.sin(time*0.002 + i)*0.01;
                }
            }
            posAttr.needsUpdate = true;
            particles.rotation.y = state.handX;

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
