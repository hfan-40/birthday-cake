<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rose Gold Cinematic Luxury</title>
    <link rel="icon" href="data:;base64,=">
    <style>
        body { margin: 0; overflow: hidden; background: #020101; font-family: 'Times New Roman', serif; user-select: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; padding-top: 6vh; }
        
        h1 {
            color: #FFD1DC; /* æ›´å°‘å¥³æ„Ÿçš„ç²‰è‰² */
            font-size: 3rem; letter-spacing: 0.5rem; text-transform: uppercase;
            text-shadow: 0 0 50px rgba(255, 182, 193, 1), 0 0 100px rgba(255, 215, 0, 0.8); /* å¼ºçƒˆçš„ç²‰é‡‘å…‰æ™• */
            margin-bottom: 15px; opacity: 0; animation: fadeIn 2s forwards 0.5s; text-align: center;
        }

        .hint-container {
            display: flex; align-items: center; gap: 10px;
            background: rgba(40, 20, 25, 0.8); border: 2px solid rgba(255, 215, 0, 0.6);
            padding: 15px 35px; border-radius: 50px; backdrop-filter: blur(20px);
            opacity: 0; animation: fadeIn 2s forwards 1.5s;
            box-shadow: 0 0 40px rgba(255, 192, 203, 0.4); /* ç²‰è‰²è¾‰å…‰å®¹å™¨ */
            transition: all 0.3s;
        }
        .hint-text { color: #FFD700; font-size: 1.2rem; letter-spacing: 1px; font-weight: 800; text-shadow: 0 0 10px rgba(255,215,0,0.5); }
        .status-dot { width: 14px; height: 14px; background: #ff0000; border-radius: 50%; transition: all 0.5s; border: 2px solid #fff; box-shadow: 0 0 10px #ff0000; }
        .status-active { background: #00ff00; box-shadow: 0 0 20px #00ff00; border-color: #ccffcc; }

        #loader { position: fixed; inset: 0; background: #020101; z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.8s ease; }
        .circle { width: 100px; height: 100px; border: 5px solid rgba(255, 182, 193, 0.3); border-top: 5px solid #FFD700; border-radius: 50%; animation: spin 0.8s infinite linear; box-shadow: 0 0 30px rgba(255,215,0,0.5); }
        .log-text { color: #FFD1DC; margin-top: 30px; font-size: 16px; letter-spacing: 4px; font-family: monospace; text-transform: uppercase; text-shadow: 0 0 20px rgba(255,182,193,0.8); }

        #webcam-preview { 
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
            border: 3px solid rgba(255, 215, 0, 0.6); border-radius: 15px; z-index: 20; 
            transform: scaleX(-1); opacity: 0; transition: opacity 0.5s;
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { to { opacity: 1; } }
    </style>
</head>
<body>

    <div id="loader">
        <div class="circle"></div>
        <div class="log-text" id="log">Loading Luxury Engine...</div>
    </div>

    <div id="ui-layer">
        <h1 id="title">Princess Celebration</h1>
        <div class="hint-container" id="hint-box">
            <span id="ai-status" class="status-dot"></span>
            <span class="hint-text" id="guide">æ­£åœ¨å¯åŠ¨ AI è§†è§‰...</span>
        </div>
    </div>

    <video id="webcam" autoplay playsinline style="display:none;"></video>
    <canvas id="webcam-preview"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';

        // --- é…ç½®ä¸­å¿ƒ (è°ƒæ•´ä¸ºæ›´äº®ã€æ›´ç²‰ã€æ›´é‡‘) ---
        const CONFIG = {
            count: 3200, // ç¨å¾®å¢åŠ ä¸€ç‚¹å¯†åº¦
            colors: {
                rose: new THREE.Color(0xFFB7C5).multiplyScalar(1.2), // æ›´äº®æ›´ç²‰çš„ç«ç‘°é‡‘
                gold: new THREE.Color(0xFFD700).multiplyScalar(1.5), // æå…¶è€€çœ¼çš„é‡‘è‰²
                ivory: new THREE.Color(0xFFFFF0).multiplyScalar(1.1), // äº®è±¡ç‰™ç™½
                flame: new THREE.Color(0xFF5500).multiplyScalar(2.0), // é«˜äº®ç«ç„°
                smoke: new THREE.Color(0x444444)
            },
            blowThreshold: 0.35, 
            spreadThreshold: 0.4, // ç¨å¾®æé«˜æ•£å¼€é˜ˆå€¼ï¼Œé˜²æ­¢è¯¯è§¦
            explodeSpeed: 12.0 // çˆ†ç‚¸é€Ÿåº¦
        };

        let scene, camera, renderer, composer, mainGroup;
        let handLandmarker, faceLandmarker, video;
        let puckerFrames = 0;
        let state = { step: 0, rotation: 0, aiReady: false }; 

        // --- æ•°æ®ç»“æ„ (åŒ…å«å®‰å…¨é¢„å¡«å……) ---
        const particleData = {
            cakePos: new Float32Array(CONFIG.count * 3),
            textPos: new Float32Array(CONFIG.count * 3),
            currentPos: new Float32Array(CONFIG.count * 3),
            currentRot: new Float32Array(CONFIG.count * 3),
            // æ–°å¢ï¼šçˆ†ç‚¸é€Ÿåº¦å‘é‡
            explodeVel: new Float32Array(CONFIG.count * 3),
            type: new Uint8Array(CONFIG.count), 
            shapeType: new Uint8Array(CONFIG.count),
            noise: new Float32Array(CONFIG.count),
            meshMapping: Array.from({length: CONFIG.count}, () => ({meshIdx: 0, instanceIdx: 0}))
        };

        const shapes = { meshes: [], dummy: new THREE.Object3D() };
        const logger = document.getElementById('log');
        const guide = document.getElementById('guide');

        // --- ä¸»ç¨‹åº ---
        async function init() {
            try {
                logger.innerText = "Creating Cinematic Scene...";
                initThree(); 
                generateShapes(); 
                
                logger.innerText = "Initializing AI...";
                await initAI();
                
                state.aiReady = true;
                document.getElementById('ai-status').classList.add('status-active');
                document.getElementById('webcam-preview').style.opacity = 1;
                guide.innerText = "âœ¨ è¯·å˜Ÿå˜´å¹ç­èœ¡çƒ›è®¸æ„¿ âœ¨";
                
            } catch (err) {
                console.warn("AI Init Failed:", err);
                state.aiReady = false;
                guide.innerText = "ğŸ–±ï¸ ç‚¹å‡»å±å¹•å¹ç­èœ¡çƒ›";
                setupMouseFallback();
            } finally {
                setTimeout(() => document.getElementById('loader').style.opacity = 0, 500);
                setTimeout(() => document.getElementById('loader').remove(), 1500);
                animate();
            }
        }

        function setupMouseFallback() {
            window.addEventListener('click', triggerBlowSequence);
            window.addEventListener('mousemove', e => {
                state.rotation = (e.clientX / window.innerWidth - 0.5) * 4;
            });
        }

        // --- äº¤äº’é€»è¾‘ ---
        function triggerBlowSequence() {
            if (state.step === 0) {
                state.step = 1; // ç†„ç­ä¸­
                setCandleColor(CONFIG.colors.smoke); // å˜çƒŸé›¾è‰²
                setTimeout(() => {
                    state.step = 2; // å˜æˆæ–‡å­—
                    updateTitle("Happy Birthday!", 1);
                    guide.innerText = state.aiReady ? "ğŸ‘ å¼ å¼€æ‰‹æŒï¼šé‡Šæ”¾é­”æ³•ç‚¸è£‚" : "ğŸ–±ï¸ ç§»åŠ¨é¼ æ ‡è§‚èµ";
                }, 1800);
            }
        }

        // æ–°å¢ï¼šé‡ç½®å›è›‹ç³•çŠ¶æ€ (é’ˆå¯¹é—®é¢˜ä¸‰)
        function resetToCake() {
            if (state.step !== 0) {
                state.step = 0;
                updateTitle("Princess Celebration", 0); // éšè—ç¥ç¦è¯­
                guide.innerText = state.aiReady ? "âœ¨ è¯·å˜Ÿå˜´å¹ç­èœ¡çƒ›è®¸æ„¿ âœ¨" : "ğŸ–±ï¸ ç‚¹å‡»å±å¹•å¹ç­èœ¡çƒ›";
                // å¼ºåˆ¶é‡æ–°ç‚¹äº®èœ¡çƒ›
                setCandleColor(CONFIG.colors.flame, CONFIG.colors.ivory);
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šè®¾ç½®èœ¡çƒ›é¢œè‰²
        function setCandleColor(flameColor, wickColor) {
            for(let i=0; i<CONFIG.count; i++) {
                const map = particleData.meshMapping[i];
                if (map && shapes.meshes[map.meshIdx]) {
                    if (particleData.type[i] === 2) { // Flame
                         shapes.meshes[map.meshIdx].setColorAt(map.instanceIdx, flameColor);
                    } else if (wickColor && particleData.type[i] === 1) { // Wick (å¯é€‰é‡ç½®)
                         shapes.meshes[map.meshIdx].setColorAt(map.instanceIdx, wickColor);
                    }
                }
            }
            shapes.meshes.forEach(m => { if(m.instanceColor) m.instanceColor.needsUpdate = true; });
        }


        function updateTitle(text, opacity) {
            const t = document.getElementById('title');
            t.style.opacity = 0;
            setTimeout(() => {
                t.innerText = text;
                // é’ˆå¯¹é—®é¢˜ä¸€ï¼šæ›´åä¸½çš„æ–‡å­—å…‰æ™•
                t.style.textShadow = opacity ? "0 0 60px #FFD700, 0 0 100px #FF69B4, 0 0 30px #fff" : "none";
                t.style.opacity = opacity;
            }, 500);
        }

        // --- Three.js åœºæ™¯æ„å»º (æ ¸å¿ƒè§†è§‰å‡çº§) ---
        function initThree() {
            scene = new THREE.Scene();
            // æ›´æ·±é‚ƒã€å¸¦ç‚¹ç²‰ç´«è‰²çš„èƒŒæ™¯é›¾
            scene.fog = new THREE.FogExp2(0x1a0510, 0.012);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 55); // ç¨å¾®æ‹‰è¿œä¸€ç‚¹è§†è§’

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // æ›´æŸ”å’Œçš„é˜´å½±
            // å¼€å¯ç‰©ç†å…‰ç…§è®¡ç®—
            renderer.physicallyCorrectLights = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // --- ç¯å…‰ç³»ç»Ÿå‡çº§ (é’ˆå¯¹é—®é¢˜ä¸€ï¼šé‡‘ç¢§è¾‰ç…Œ) ---
            const ambient = new THREE.AmbientLight(0xffcce0, 0.6); // æš–ç²‰è‰²ç¯å¢ƒå…‰
            scene.add(ambient);
            
            // ä¸»å…‰æºï¼šé‡‘è‰²å¼ºå…‰
            const dirLight = new THREE.DirectionalLight(0xffd700, 4.0);
            dirLight.position.set(15, 25, 15);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
            
            // è¡¥å…‰ï¼šç«ç‘°è‰²ä¾§å…‰
            const pointLightRose = new THREE.PointLight(0xff69b4, 3.5, 80);
            pointLightRose.position.set(-20, 10, -10);
            scene.add(pointLightRose);

            // æ–°å¢ï¼šè›‹ç³•ä¸­å¿ƒçƒ›å…‰è¡¥å…‰ (ç…§äº®è›‹ç³•ä½“)
            const centerLight = new THREE.PointLight(0xffaa55, 3.0, 30);
            centerLight.position.set(0, 8, 0);
            mainGroup.add(centerLight);

            // --- åå¤„ç† (é’ˆå¯¹é—®é¢˜ä¸€ï¼šç”µå½±æ„Ÿè¾‰å…‰) ---
            // å‚æ•°æå…¶æ¿€è¿›ï¼šé˜ˆå€¼æä½ï¼Œå¼ºåº¦æé«˜ï¼ŒåŠå¾„å¤§
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.8, 1.0, 0.15);
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);

            // --- æè´¨å‡çº§ (é’ˆå¯¹é—®é¢˜ä¸€ï¼šé«˜çº§æ„Ÿ) ---
            // åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿç¯å¢ƒçº¹ç†ç”¨äºåå°„ (ç®€æ˜“ç‰ˆï¼Œæ— éœ€å¤–éƒ¨æ–‡ä»¶)
            const envMap = new THREE.RenderTargetCube(256, 256);
            // ç«ç‘°é‡‘ï¼šæåº¦å…‰æ»‘ï¼Œå¸¦ç²‰è‰²åå°„
            const matRough = new THREE.MeshStandardMaterial({ color: CONFIG.colors.rose, roughness: 0.3, metalness: 0.6, envMap: envMap.texture });
            // é‡‘å±é‡‘ï¼šé•œé¢çº§åˆ«ï¼Œé‡‘ç¢§è¾‰ç…Œ
            const matMetal = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.05, metalness: 1.0, envMap: envMap.texture, envMapIntensity: 1.5 });
            // è±¡ç‰™ç™½ï¼šæŠ›å…‰é™¶ç“·æ„Ÿ
            const matIvory = new THREE.MeshStandardMaterial({ color: CONFIG.colors.ivory, roughness: 0.2, metalness: 0.1 });
            
            const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle='#fff'; ctx.fillRect(0,0,256,256); ctx.fillStyle='#000'; ctx.fillRect(10,10,236,236);
            const grad = ctx.createLinearGradient(10,10,246,246); grad.addColorStop(0,'#ffc3a0'); grad.addColorStop(0.5,'#ffafbd'); grad.addColorStop(1,'#ffc3a0');
            ctx.fillStyle=grad; ctx.fillRect(10,10,236,236);
            ctx.fillStyle='#fff'; ctx.font='italic bold 28px "Times New Roman"'; ctx.textAlign='center'; ctx.fillText('Sweet',128,220); ctx.fillText('Dreams',128,250);
            ctx.strokeStyle='#ffd700'; ctx.lineWidth=5; ctx.strokeRect(15,15,226,226);
            const matPhoto = new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), side: THREE.DoubleSide });

            // å‡ ä½•ä½“
            const sphereGeo = new THREE.SphereGeometry(0.35, 24, 24); // æé«˜åˆ†æ®µæ•°æ›´åœ†æ¶¦
            const boxGeo = new THREE.BoxGeometry(0.45, 0.45, 0.45);
            const candyGeo = new THREE.CylinderGeometry(0.12, 0.12, 1.4, 16);
            const photoGeo = new THREE.PlaneGeometry(0.85, 0.85);
            
            const maxCount = CONFIG.count; 
            shapes.meshes.push(new THREE.InstancedMesh(sphereGeo, matRough, maxCount)); // 0
            shapes.meshes.push(new THREE.InstancedMesh(boxGeo, matMetal, maxCount));    // 1
            shapes.meshes.push(new THREE.InstancedMesh(candyGeo, matIvory, maxCount));  // 2
            shapes.meshes.push(new THREE.InstancedMesh(photoGeo, matPhoto, maxCount));  // 3

            shapes.meshes.forEach(m => {
                m.receiveShadow = true; m.castShadow = true;
                m.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                mainGroup.add(m);
            });
        }

        // --- æ•°æ®ç”Ÿæˆé€»è¾‘ ---
        function generateShapes() {
            const typeCounts = [0, 0, 0, 0];
            let idx = 0;

            // 1. è›‹ç³•ä¸»ä½“
            const bodyEnd = Math.floor(CONFIG.count * 0.82);
            for(; idx < bodyEnd; idx++) {
                const angle = Math.random() * Math.PI * 2;
                let r, y;
                if(Math.random() > 0.4) { r = 9 + Math.random()*2; y = Math.random()*6-4; } 
                else { r = 6 + Math.random()*1.5; y = Math.random()*5+2.5; }

                particleData.cakePos[idx*3] = Math.cos(angle)*r;
                particleData.cakePos[idx*3+1] = y;
                particleData.cakePos[idx*3+2] = Math.sin(angle)*r;
                particleData.type[idx] = 0;

                const shapeRnd = Math.random();
                let shapeType = shapeRnd > 0.7 ? 0 : (shapeRnd > 0.4 ? 1 : 3);
                particleData.shapeType[idx] = shapeType;
                assignMeshMapping(idx, shapeType, typeCounts);

                const colorRnd = Math.random();
                // è°ƒæ•´é¢œè‰²åˆ†é…æ¯”ä¾‹ï¼Œæ›´å¤šé‡‘è‰²å’Œç«ç‘°è‰²
                let color = colorRnd > 0.5 ? CONFIG.colors.rose : (colorRnd > 0.2 ? CONFIG.colors.gold : CONFIG.colors.ivory);
                if(shapeType === 3) color = new THREE.Color(1,1,1);
                setInstanceColor(idx, color);
                
                // é’ˆå¯¹é—®é¢˜äºŒï¼šé¢„è®¡ç®—çˆ†ç‚¸é€Ÿåº¦å‘é‡ (ä»ä¸­å¿ƒå‘å¤–)
                const explodeDir = new THREE.Vector3(particleData.cakePos[idx*3], y - 4, particleData.cakePos[idx*3+2]).normalize();
                particleData.explodeVel[idx*3] = explodeDir.x * CONFIG.explodeSpeed * (0.5 + Math.random());
                particleData.explodeVel[idx*3+1] = explodeDir.y * CONFIG.explodeSpeed * (0.5 + Math.random());
                particleData.explodeVel[idx*3+2] = explodeDir.z * CONFIG.explodeSpeed * (0.5 + Math.random());
            }

            // 2. èœ¡çƒ›ä¸ç«ç„°
            const remaining = CONFIG.count - idx;
            const candles = 7;
            const perCandle = Math.floor(remaining / candles);

            for(let c=0; c<candles; c++) {
                const countForThis = (c === candles - 1) ? (CONFIG.count - idx) : perCandle;
                const angle = (c/candles)*Math.PI*2; const cx = Math.cos(angle)*4; const cz = Math.sin(angle)*4; const cy = 8;

                for(let k=0; k<countForThis; k++) {
                    if (idx >= CONFIG.count) break;
                    // é’ˆå¯¹é—®é¢˜äºŒï¼šèœ¡çƒ›çš„çˆ†ç‚¸é€Ÿåº¦å‘ä¸Šä¸ºä¸»
                    particleData.explodeVel[idx*3] = (Math.random()-0.5) * CONFIG.explodeSpeed;
                    particleData.explodeVel[idx*3+1] = (0.5 + Math.random()) * CONFIG.explodeSpeed * 1.5;
                    particleData.explodeVel[idx*3+2] = (Math.random()-0.5) * CONFIG.explodeSpeed;

                    if(k < countForThis * 0.6) { // çƒ›èŠ¯
                        particleData.cakePos[idx*3]=cx+(Math.random()-0.5)*0.3; particleData.cakePos[idx*3+1]=cy+Math.random()*3; particleData.cakePos[idx*3+2]=cz+(Math.random()-0.5)*0.3;
                        particleData.type[idx] = 1; particleData.shapeType[idx] = 2; 
                        assignMeshMapping(idx, 2, typeCounts); setInstanceColor(idx, CONFIG.colors.ivory);
                    } else { // ç«ç„°
                        particleData.cakePos[idx*3]=cx+(Math.random()-0.5)*0.4; particleData.cakePos[idx*3+1]=cy+3.5+Math.random()*1.5; particleData.cakePos[idx*3+2]=cz+(Math.random()-0.5)*0.4;
                        particleData.type[idx] = 2; particleData.shapeType[idx] = 0; 
                        assignMeshMapping(idx, 0, typeCounts); setInstanceColor(idx, CONFIG.colors.flame);
                    }
                    idx++;
                }
            }

            // 3. æ–‡å­—ç›®æ ‡
            const cvs = document.createElement('canvas'); cvs.width=800; cvs.height=200; // åŠ å¤§ç”»å¸ƒ
            const ctx = cvs.getContext('2d'); ctx.font='900 80px "Times New Roman"'; ctx.fillStyle='white'; ctx.textAlign='center'; 
            ctx.fillText('HAPPY BIRTHDAY', 400, 120);
            const data = ctx.getImageData(0,0,800,200).data; const valid = [];
            for(let y=0; y<200; y+=4) for(let x=0; x<800; x+=4) if(data[(y*800+x)*4]>128) valid.push({x:(x-400)*0.15, y:(100-y)*0.15+8});
            
            for(let i=0; i<CONFIG.count; i++) {
                const p = valid[i%valid.length];
                particleData.textPos[i*3] = p.x; particleData.textPos[i*3+1] = p.y; particleData.textPos[i*3+2] = (Math.random()-0.5)*3;
                particleData.currentRot[i*3] = Math.random()*Math.PI; particleData.currentRot[i*3+1] = Math.random()*Math.PI; particleData.currentRot[i*3+2] = Math.random()*Math.PI;
                particleData.noise[i] = Math.random()*100;
            }

            shapes.meshes.forEach(m => { m.instanceMatrix.needsUpdate = true; m.instanceColor.needsUpdate = true; });
        }

        function assignMeshMapping(particleIdx, shapeType, typeCounts) {
            if (particleIdx >= CONFIG.count) return;
            particleData.meshMapping[particleIdx] = { meshIdx: shapeType, instanceIdx: typeCounts[shapeType]++ };
        }
        function setInstanceColor(particleIdx, color) {
            if (particleIdx >= CONFIG.count) return;
            const map = particleData.meshMapping[particleIdx];
            if (map && shapes.meshes[map.meshIdx]) {
                shapes.meshes[map.meshIdx].setColorAt(map.instanceIdx, color);
            }
        }

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", outputFaceBlendshapes: true
            });
            video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            return new Promise(resolve => video.onloadeddata = resolve);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            if (state.aiReady && video.readyState >= 2) {
                const pc = document.getElementById('webcam-preview');
                pc.getContext('2d').drawImage(video, 0, 0, pc.width, pc.height);
                const t = performance.now();

                if (state.step === 0) { // å¹æ°”æ£€æµ‹
                    const face = faceLandmarker.detectForVideo(video, t);
                    if (face.faceBlendshapes.length > 0) {
                        const pucker = face.faceBlendshapes[0].categories.find(c => c.categoryName === 'mouthPucker').score;
                        if (pucker > CONFIG.blowThreshold) { puckerFrames++; if (puckerFrames > 8) triggerBlowSequence(); } else puckerFrames = 0;
                    }
                }
                
                // æ‰‹åŠ¿æ£€æµ‹ (æ ¸å¿ƒé€»è¾‘ä¿®æ”¹é’ˆå¯¹é—®é¢˜ä¸‰)
                const hand = handLandmarker.detectForVideo(video, t);
                if (hand.landmarks.length > 0) {
                    const lm = hand.landmarks[0];
                    const spread = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    state.rotation = (lm[9].x - 0.5) * 5; // åŠ å¿«æ—‹è½¬çµæ•åº¦
                    
                    if (state.step >= 2) { 
                        // å¦‚æœå¼ å¼€ï¼Œè¿›å…¥çˆ†ç‚¸çŠ¶æ€(3)
                        if (spread > CONFIG.spreadThreshold) {
                            state.step = 3;
                        } 
                        // é’ˆå¯¹é—®é¢˜ä¸‰ï¼šå¦‚æœåˆæ‹¢ï¼Œä¸”å½“å‰æ˜¯çˆ†ç‚¸çŠ¶æ€ï¼Œåˆ™é‡ç½®å›è›‹ç³•(0)
                        else if (state.step === 3 && spread <= CONFIG.spreadThreshold) {
                            resetToCake();
                        }
                        // å¦‚æœæ˜¯æ–‡å­—çŠ¶æ€ä¸”åˆæ‹¢ï¼Œä¿æŒæ–‡å­—çŠ¶æ€(2)
                    }
                }
            }

            const pos = particleData.currentPos;
            const rot = particleData.currentRot;
            // é’ˆå¯¹é—®é¢˜ä¸‰ï¼šç›®æ ‡é€‰æ‹©é€»è¾‘æ›´æ–°
            let target = (state.step === 0 || state.step === 1) ? particleData.cakePos : particleData.textPos;

            for(let i=0; i<CONFIG.count; i++) {
                const i3 = i*3;
                
                // åŠ¨ç”»é€»è¾‘
                if (state.step === 0 && particleData.type[i] === 2) { // ç«ç„°è·³åŠ¨
                    pos[i3] += (Math.random()-0.5)*0.1; 
                    particleData.cakePos[i3+1] += Math.sin(time*15+i)*0.05;
                }
                
                if (state.step === 1 && particleData.type[i] === 2) { // çƒŸé›¾ä¸Šé£˜
                    pos[i3+1] += 0.2; pos[i3] += Math.sin(time*5+i)*0.05; 
                    rot[i3]+=0.15; rot[i3+2]+=0.15;
                }

                // é’ˆå¯¹é—®é¢˜äºŒï¼šçˆ†ç‚¸é€»è¾‘ (ä½¿ç”¨é¢„è®¡ç®—çš„é€Ÿåº¦å‘é‡)
                if (state.step === 3) {
                    pos[i3] += particleData.explodeVel[i3] * 0.1;
                    pos[i3+1] += particleData.explodeVel[i3+1] * 0.1;
                    pos[i3+2] += particleData.explodeVel[i3+2] * 0.1;
                    rot[i3]+=0.1; rot[i3+1]+=0.1;
                } 
                // èšåˆé€»è¾‘ (Step 0, 1, 2)
                else if (state.step !== 1 || particleData.type[i] !== 2) {
                    // å›å½’è›‹ç³•æ—¶é€Ÿåº¦åŠ å¿«
                    const speed = (state.step === 0) ? 0.15 : ((state.step === 2) ? 0.08 : 0.12);
                    pos[i3] += (target[i3] - pos[i3]) * speed;
                    pos[i3+1] += (target[i3+1] - pos[i3+1]) * speed;
                    pos[i3+2] += (target[i3+2] - pos[i3+2]) * speed;
                }

                // æ›´æ–° InstancedMesh
                const map = particleData.meshMapping[i];
                if (map && shapes.meshes[map.meshIdx]) {
                    shapes.dummy.position.set(pos[i3], pos[i3+1], pos[i3+2]);
                    shapes.dummy.rotation.set(rot[i3], rot[i3+1], rot[i3+2]);
                    
                    // ç«ç„°å’Œç…§ç‰‡ç¨å¾®å¤§ä¸€ç‚¹
                    let scale = particleData.type[i] === 2 ? 1.6 : (particleData.shapeType[i]===3 ? 1.3 : 1);
                    // çˆ†ç‚¸æ—¶ç¨å¾®ç¼©å°
                    if(state.step === 3) scale *= 0.8;
                    shapes.dummy.scale.set(scale, scale, scale);
                    
                    shapes.dummy.updateMatrix();
                    shapes.meshes[map.meshIdx].setMatrixAt(map.instanceIdx, shapes.dummy.matrix);
                }
            }

            shapes.meshes.forEach(m => m.instanceMatrix.needsUpdate = true);
            if(mainGroup) mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, state.rotation, 0.05);
            // ç¼“æ…¢è‡ªè½¬å¢åŠ åŠ¨æ„Ÿ
            if(mainGroup && !state.aiReady) mainGroup.rotation.y += 0.002;

            composer.render();
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); 
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
