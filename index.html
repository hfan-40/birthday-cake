<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Particle Birthday Cake - Gesture Control</title>
    <style>
        @import url('https://gs.jurieo.com/gemini/fonts-googleapis/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;1,400&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Playfair Display', serif;
            color: #fff;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            text-align: center;
            text-shadow: 0 0 20px rgba(255, 192, 203, 0.8);
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            margin: 0;
            letter-spacing: 5px;
            background: linear-gradient(to right, #bf953f, #fcf6ba, #b38728, #fbf5b7, #aa771c);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .status-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 300px;
            pointer-events: auto;
        }

        .status-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            margin-right: 10px;
            box-shadow: 0 0 5px #444;
            transition: all 0.3s;
        }

        .status-dot.active {
            background: #0f0;
            box-shadow: 0 0 10px #0f0;
        }

        .controls {
            pointer-events: auto;
            text-align: center;
            margin-bottom: 20px;
        }

        .btn {
            background: rgba(255, 192, 203, 0.2);
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #fff;
            padding: 12px 30px;
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
            backdrop-filter: blur(5px);
        }

        .btn:hover {
            background: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        #file-input {
            display: none;
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 1s;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,215,0,0.3);
            border-radius: 50%;
            border-top-color: #FFD700;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .video-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            border-radius: 10px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            opacity: 0.5;
            z-index: 20;
            pointer-events: none;
        }

        .guide-text {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.8rem;
            margin-top: 5px;
        }
    </style>

    <!-- Three.js & Post Processing -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <div style="font-family: 'Cinzel'; color: #FFD700;">INITIALIZING MAGIC...</div>
        <div class="guide-text">Please allow camera access</div>
    </div>

    <div id="ui-layer">
        <div class="status-panel">
            <h3 style="margin-top:0; color:#FFD700; border-bottom:1px solid #555; padding-bottom:5px;">Magic Control</h3>
            <div class="status-item"><div class="status-dot" id="st-hand"></div> Hand Detected</div>
            <div class="status-item"><div class="status-dot" id="st-face"></div> Face Detected</div>
            <div class="status-item"><div class="status-dot" id="st-gesture"></div> Gesture: <span id="gesture-name" style="margin-left:5px; color:#FFB7C5;">None</span></div>
            <div class="guide-text">
                âœŠ æ¡æ‹³: ç»„åˆè›‹ç³•<br>
                ğŸ–ï¸ å¼ å¼€: çˆ†ç‚¸æ•£å¼€<br>
                ğŸ˜— å˜Ÿå˜´: å¹ç­èœ¡çƒ› & ç”Ÿæ—¥å¿«ä¹<br>
                ğŸ¤ æåˆ: æŠ“å–ç…§ç‰‡<br>
                ğŸ‘‹ ç§»åŠ¨: æ—‹è½¬è§†è§’
            </div>
        </div>

        <div class="controls">
            <button class="btn" onclick="document.getElementById('file-input').click()">Upload Memory Photo</button>
            <input type="file" id="file-input" accept="image/*" multiple>
        </div>
    </div>

    <div id="canvas-container"></div>
    <video class="video-feed" id="input_video"></video>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            particleCount: 6000,
            colors: [0xFFD700, 0xFFC0CB, 0xFFFFFF, 0xE6E6FA], // Gold, Pink, White, Lavender
            cakeRadiusBot: 15,
            cakeRadiusTop: 10,
            text: "HAPPY BIRTHDAY",
            cameraZ: 60
        };

        let scene, camera, renderer, composer, controls;
        let particles, dummy;
        let particlePositions = []; // å­˜å‚¨å½“å‰ä½ç½®
        let targetPositions = []; // å­˜å‚¨ç›®æ ‡ä½ç½®
        let particleColors = [];
        let geometryText = null;
        let uploadedTextures = [];
        let photoMeshes = [];
        
        // çŠ¶æ€ç®¡ç†
        const STATE = {
            CAKE: 'cake',
            EXPLODE: 'explode',
            TEXT: 'text',
            PHOTO: 'photo'
        };
        let currentState = STATE.CAKE;
        let isCandleLit = true;
        let flameParticles = [];

        // äº¤äº’æ•°æ®
        let handPresence = false;
        let facePresence = false;
        let currentGesture = 'None';
        let handPos = { x: 0, y: 0, z: 0 };
        let isPouting = false;

        // åˆå§‹åŒ–
        init();
        initAI();
        animate();

        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.005);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, CONFIG.cameraZ);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // è½¨é“æ§åˆ¶ (ç”¨äºé¼ æ ‡è°ƒè¯•ï¼Œæ‰‹åŠ¿ä¹Ÿä¼šæ§åˆ¶å®ƒ)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // åå¤„ç† (Bloomæ•ˆæœ)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2; // å¼ºå…‰æ™•
            bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç²’å­ç³»ç»Ÿåˆå§‹åŒ–
            initParticles();
            
            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xFFD700, 1, 100);
            pointLight.position.set(0, 20, 20);
            scene.add(pointLight);

            // åŠ è½½å­—ä½“
            const loader = new FontLoader();
            loader.load('https://cdn.jsdelivr.net/npm/three@0.154.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                const textGeo = new TextGeometry(CONFIG.text, {
                    font: font,
                    size: 4,
                    height: 0.5,
                    curveSegments: 4,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.05,
                    bevelSegments: 2
                });
                textGeo.center();
                geometryText = textGeo;
                console.log("Font Loaded");
            });

            // ç…§ç‰‡ä¸Šä¼ ç›‘å¬
            document.getElementById('file-input').addEventListener('change', handleFileUpload);

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
        }

        function initParticles() {
            // ä½¿ç”¨ InstancedMesh
            const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3); // å°æ–¹å—ç²’å­ï¼Œåƒé‡‘ç®”
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            particles = new THREE.InstancedMesh(geometry, material, CONFIG.particleCount);
            particles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            
            dummy = new THREE.Object3D();
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // åˆå§‹åŒ–ä½ç½®ï¼šéšæœºæ•£å¼€
                const pos = getRandomPosition(50);
                particlePositions.push(pos.clone());
                targetPositions.push(pos.clone());
                
                // é¢œè‰²
                const colorHex = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                particles.setColorAt(i, new THREE.Color(colorHex));
                
                dummy.position.copy(pos);
                dummy.updateMatrix();
                particles.setMatrixAt(i, dummy.matrix);
            }
            
            scene.add(particles);
            
            // ç«‹å³ç”Ÿæˆè›‹ç³•å½¢çŠ¶ä½œä¸ºç›®æ ‡
            generateCakeShape();
        }

        function handleFileUpload(event) {
            const files = event.target.files;
            if (files.length > 0) {
                const file = files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.src = e.target.result;
                    const texture = new THREE.TextureLoader().load(e.target.result);
                    uploadedTextures.push(texture);
                    
                    // åˆ›å»ºä¸€ä¸ªæ¼‚æµ®çš„ç…§ç‰‡Mesh
                    const photoGeo = new THREE.PlaneGeometry(15, 20); // ç«–å›¾æ¯”ä¾‹
                    const photoMat = new THREE.MeshBasicMaterial({ 
                        map: texture, 
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0
                    });
                    const mesh = new THREE.Mesh(photoGeo, photoMat);
                    mesh.position.set( (Math.random()-0.5)*40, (Math.random()-0.5)*20, (Math.random()-0.5)*20 );
                    scene.add(mesh);
                    photoMeshes.push({ mesh: mesh, targetOpacity: 0, originalPos: mesh.position.clone() });
                };
                reader.readAsDataURL(file);
            }
        }

        // --- å½¢çŠ¶ç”Ÿæˆç®—æ³• ---

        function getRandomPosition(radius) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = Math.pow(Math.random(), 1/3) * radius;
            return new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }

        function generateCakeShape() {
            // åº•å±‚
            let idx = 0;
            const tier1Count = Math.floor(CONFIG.particleCount * 0.4);
            const tier2Count = Math.floor(CONFIG.particleCount * 0.3);
            const candleCount = Math.floor(CONFIG.particleCount * 0.1);
            
            // Tier 1 (Bottom)
            for (let i = 0; i < tier1Count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * CONFIG.cakeRadiusBot;
                const h = (Math.random() - 0.5) * 8 - 5; // y: -9 to -1
                targetPositions[idx++].set(r * Math.cos(theta), h, r * Math.sin(theta));
            }
            
            // Tier 2 (Top)
            for (let i = 0; i < tier2Count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * CONFIG.cakeRadiusTop;
                const h = (Math.random() - 0.5) * 6 + 3; // y: 0 to 6
                targetPositions[idx++].set(r * Math.cos(theta), h, r * Math.sin(theta));
            }

            // Candle
            for (let i = 0; i < candleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * 0.8;
                const h = Math.random() * 8 + 6; // y: 6 to 14
                targetPositions[idx++].set(r * Math.cos(theta), h, r * Math.sin(theta));
            }

            // Flame (å‰©ä½™ç²’å­)
            flameParticles = []; // è®°å½•ç«ç„°ç²’å­çš„ç´¢å¼•ï¼Œç”¨äºé—ªçƒ
            while(idx < CONFIG.particleCount) {
                const r = Math.random() * 0.5;
                const theta = Math.random() * Math.PI * 2;
                const h = Math.random() * 3 + 14.5; 
                // ç«ç„°å½¢çŠ¶ç•¥å‘ˆæ°´æ»´
                const pos = new THREE.Vector3(r * Math.cos(theta) * (1-(h-14.5)/3), h, r * Math.sin(theta) * (1-(h-14.5)/3));
                targetPositions[idx].copy(pos);
                flameParticles.push(idx);
                idx++;
            }
        }

        function generateExplodeShape() {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                targetPositions[i].copy(getRandomPosition(40));
            }
        }

        function generateTextShape() {
            if (!geometryText) return; // å­—ä½“æœªåŠ è½½
            
            // ä»TextGeometryè·å–é¡¶ç‚¹
            // æ³¨æ„ï¼šè¿™åªæ˜¯è¡¨é¢ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦å¡«å……ä½“ç§¯æˆ–éšæœºé‡‡æ ·
            // ç®€å•æ–¹æ³•ï¼šéšæœºåˆ†å¸ƒåœ¨åŒ…å›´ç›’å†…ï¼Œç„¶åå‰”é™¤ä¸åœ¨Meshå†…éƒ¨çš„ç‚¹ï¼ˆå¤æ‚ï¼‰ï¼Œæˆ–è€…ç›´æ¥ä½¿ç”¨è¡¨é¢ç‚¹ã€‚
            // ç®€å•æ–¹æ³•2ï¼šéšæœºé‡‡æ ·ä¸‰è§’å½¢è¡¨é¢
            
            const posAttribute = geometryText.attributes.position;
            const vertexCount = posAttribute.count;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // éšæœºé€‰æ‹©ä¸€ä¸ªä¸‰è§’å½¢
                const triangleIndex = Math.floor(Math.random() * (vertexCount / 3));
                const i3 = triangleIndex * 3;
                
                const vA = new THREE.Vector3().fromBufferAttribute(posAttribute, i3);
                const vB = new THREE.Vector3().fromBufferAttribute(posAttribute, i3 + 1);
                const vC = new THREE.Vector3().fromBufferAttribute(posAttribute, i3 + 2);
                
                // éšæœºé‡å¿ƒåæ ‡
                let r1 = Math.random();
                let r2 = Math.random();
                if (r1 + r2 > 1) { r1 = 1 - r1; r2 = 1 - r2; }
                
                const p = new THREE.Vector3()
                    .addScaledVector(vA, r1)
                    .addScaledVector(vB, r2)
                    .addScaledVector(vC, 1 - r1 - r2);
                
                // æ•£å¼€ä¸€ç‚¹ç‚¹è®©æ–‡å­—æœ‰åšåº¦æ„Ÿ
                p.z += (Math.random()-0.5) * 2;
                
                targetPositions[i].copy(p);
            }
        }

        // --- åŠ¨ç”»å¾ªç¯ ---

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // 1. ç²’å­è¿åŠ¨é€»è¾‘ (Lerp)
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const current = particlePositions[i];
                const target = targetPositions[i];
                
                // ç®€å•çš„ç¼“åŠ¨ï¼šæ¯æ¬¡ç§»åŠ¨è·ç¦»çš„ 5%
                // æ ¹æ®ä¸åŒçŠ¶æ€è°ƒæ•´é€Ÿåº¦
                let speed = 0.05;
                if (currentState === STATE.EXPLODE) speed = 0.02; // æ¼‚æµ®æ…¢ä¸€ç‚¹

                // å¦‚æœæ˜¯ç«ç„°ä¸”èœ¡çƒ›ç‚¹ç‡ƒï¼ŒåŠ å™ªç‚¹
                if (isCandleLit && flameParticles.includes(i)) {
                    // ç«ç„°æ‘‡æ›³
                    current.x += (Math.random() - 0.5) * 0.2;
                    current.z += (Math.random() - 0.5) * 0.2;
                    current.y = target.y + Math.sin(time * 10 + i) * 0.5; // ä¸Šä¸‹è·³åŠ¨
                    
                    // è¿˜è¦æ…¢æ…¢å›å½’ä¸­å¿ƒ
                    current.lerp(target, 0.1); 
                } else {
                    current.lerp(target, speed);
                    
                    // æ•£å¼€çŠ¶æ€ä¸‹åŠ ä¸Šæ­£å¼¦æ³¢æ¼‚æµ®
                    if (currentState === STATE.EXPLODE || currentState === STATE.PHOTO) {
                        current.y += Math.sin(time + i) * 0.02;
                    }
                }

                dummy.position.copy(current);
                
                // å¦‚æœæ˜¯ç«ç„°ï¼Œæ”¹é¢œè‰²
                if (flameParticles.includes(i)) {
                    if (isCandleLit) {
                        const flicker = Math.random() > 0.8 ? 0xffaa00 : 0xff4500;
                        particles.setColorAt(i, new THREE.Color(flicker));
                    } else {
                        // ç†„ç­å˜ç°
                        particles.setColorAt(i, new THREE.Color(0x888888));
                    }
                }

                dummy.updateMatrix();
                particles.setMatrixAt(i, dummy.matrix);
            }
            particles.instanceMatrix.needsUpdate = true;
            if (flameParticles.length > 0) particles.instanceColor.needsUpdate = true;

            // 2. ç…§ç‰‡åŠ¨ç”»
            photoMeshes.forEach(item => {
                // å¦‚æœæ˜¯ Photo State ä¸”è¢«é€‰ä¸­(è¿™é‡Œç®€åŒ–ä¸ºåªæ˜¾ç¤ºç¬¬ä¸€å¼ )ï¼Œç§»åŠ¨åˆ°å±å¹•ä¸­é—´
                if (currentState === STATE.PHOTO && uploadedTextures.length > 0) {
                     // ç›®æ ‡æ˜¯é•œå¤´å‰
                     const target = new THREE.Vector3(0, 0, 40);
                     item.mesh.position.lerp(target, 0.05);
                     item.mesh.rotation.set(0,0,0);
                     item.targetOpacity = 1;
                } else if (currentState === STATE.EXPLODE) {
                     // æ•£å¼€åœ¨å‘¨å›´
                     item.mesh.position.lerp(item.originalPos, 0.02);
                     item.mesh.rotation.y += 0.01;
                     item.targetOpacity = 0.8;
                } else {
                     // éšè—
                     item.targetOpacity = 0;
                }
                
                // Opacity Lerp
                item.mesh.material.opacity += (item.targetOpacity - item.mesh.material.opacity) * 0.05;
            });

            // 3. äº¤äº’é©±åŠ¨çš„ç›¸æœºæ§åˆ¶
            if (currentState === STATE.EXPLODE && handPresence) {
                // æ‰‹çš„Xä½ç½®æ§åˆ¶ç›¸æœºæ—‹è½¬
                controls.autoRotate = false;
                const targetRot = (handPos.x - 0.5) * 2 * Math.PI; // -PI to PI
                // ç¼“åŠ¨ç›¸æœº
                const r = CONFIG.cameraZ;
                camera.position.x += (Math.sin(targetRot) * r - camera.position.x) * 0.05;
                camera.position.z += (Math.cos(targetRot) * r - camera.position.z) * 0.05;
                camera.lookAt(0,0,0);
            } else {
                controls.update();
            }

            composer.render();
        }

        // --- AI & äº¤äº’é€»è¾‘ ---
        
        function initAI() {
            const videoElement = document.getElementById('input_video');

            // Hands
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            hands.onResults(onHandResults);

            // Face Mesh
            const faceMesh = new FaceMesh({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }});
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            faceMesh.onResults(onFaceResults);

            // Camera Setup
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                    await faceMesh.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            // Start button logic implicitly or explicitly
            // è¿™é‡Œä¸ºäº†ä½“éªŒç›´æ¥å¯åŠ¨ï¼Œä½†åœ¨ç°ä»£æµè§ˆå™¨å¯èƒ½éœ€è¦ç”¨æˆ·ç‚¹å‡»
            // æˆ‘ä»¬é€šè¿‡ä¸Šé¢çš„Loading Screenæç¤ºç”¨æˆ·å…è®¸æ‘„åƒå¤´
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loading-screen').style.opacity = 0;
                    setTimeout(() => document.getElementById('loading-screen').remove(), 1000);
                })
                .catch(err => {
                    console.error("Camera error:", err);
                    alert("è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¼€å¯é­”æ³•ä½“éªŒ");
                });
        }

        function onHandResults(results) {
            handPresence = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;
            document.getElementById('st-hand').classList.toggle('active', handPresence);

            if (handPresence) {
                const landmarks = results.multiHandLandmarks[0];
                
                // è®¡ç®—é‡å¿ƒç”¨äºæ§åˆ¶ç›¸æœº
                handPos.x = landmarks[9].x; // ä¸­æŒ‡æ ¹éƒ¨
                handPos.y = landmarks[9].y;

                // ç®€å•çš„æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
                detectGesture(landmarks);
            }
        }

        function onFaceResults(results) {
            facePresence = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
            document.getElementById('st-face').classList.toggle('active', facePresence);

            if (facePresence) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // æ£€æµ‹å˜Ÿå˜´ (Pout)
                // ä¸Šå”‡: 13, ä¸‹å”‡: 14. å˜´è§’: 61, 291
                // é€»è¾‘: å˜´å®½å˜çª„ï¼Œä¸”å˜´å”‡ä¸­å¿ƒè·ç¦»é€‚ä¸­
                
                const upperLip = landmarks[13];
                const lowerLip = landmarks[14];
                const leftCorner = landmarks[61];
                const rightCorner = landmarks[291];

                const mouthHeight = Math.abs(upperLip.y - lowerLip.y);
                const mouthWidth = Math.abs(leftCorner.x - rightCorner.x);
                
                // æ¯”ä¾‹é˜ˆå€¼éœ€è¦è°ƒè¯•ï¼Œè¿™é‡Œå‡è®¾ width/height < 1.5 ä¸ºå˜Ÿå˜´/å¼ å˜´Oå‹
                const ratio = mouthWidth / mouthHeight;
                
                // å¿…é¡»åœ¨è›‹ç³•æ¨¡å¼ä¸‹æ‰æ£€æµ‹å¹ç­
                if (currentState === STATE.CAKE && ratio < 1.8 && mouthHeight > 0.02) { 
                    if (!isPouting) {
                        // è§¦å‘ä¸€æ¬¡å¹ç­
                        console.log("Blow Detected!");
                        isPouting = true;
                        triggerBlowCandle();
                    }
                } else {
                    isPouting = false;
                }
            }
        }

        function detectGesture(landmarks) {
            // è®¡ç®—æ‰‹æŒ‡ä¼¸å±•æƒ…å†µ
            // æŒ‡å°– vs æŒ‡æ ¹ (Tip vs PIP/MCP)
            const isThumbOpen = landmarks[4].x < landmarks[3].x; // ç®€åŒ–åˆ¤æ–­
            const isIndexOpen = landmarks[8].y < landmarks[6].y;
            const isMiddleOpen = landmarks[12].y < landmarks[10].y;
            const isRingOpen = landmarks[16].y < landmarks[14].y;
            const isPinkyOpen = landmarks[20].y < landmarks[18].y;

            let fingersOpen = 0;
            if(isIndexOpen) fingersOpen++;
            if(isMiddleOpen) fingersOpen++;
            if(isRingOpen) fingersOpen++;
            if(isPinkyOpen) fingersOpen++;

            // 1. æ¡æ‹³ (Fist) -> Cake
            if (fingersOpen === 0) {
                updateState(STATE.CAKE);
                currentGesture = "Fist (Reset)";
                isCandleLit = true; // é‡ç½®èœ¡çƒ›
            }
            // 2. å¼ å¼€ (Open Palm) -> Explode
            else if (fingersOpen >= 4) {
                // å¦‚æœå½“å‰æ˜¯ Textï¼Œä¹Ÿå¯ä»¥ç‚¸å¼€
                if (currentState === STATE.CAKE || currentState === STATE.TEXT) {
                    updateState(STATE.EXPLODE);
                }
                currentGesture = "Open Hand (Explode)";
            }
            // 3. æåˆ (Pinch) -> Photo
            // æ‹‡æŒ‡(4) å’Œ é£ŸæŒ‡(8) è·ç¦»å¾ˆè¿‘
            const pinchDist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
            if (pinchDist < 0.05 && fingersOpen < 3) {
                if (uploadedTextures.length > 0) {
                    updateState(STATE.PHOTO);
                    currentGesture = "Pinch (Show Photo)";
                } else {
                    currentGesture = "Pinch (No Photo)";
                }
            }
            else {
                // ç§»åŠ¨æ‰‹æŒ
                currentGesture = "Moving";
            }

            document.getElementById('gesture-name').innerText = currentGesture;
        }

        function triggerBlowCandle() {
            // å¹ç­èœ¡çƒ›æ•ˆæœ
            isCandleLit = false;
            
            // 1ç§’åå˜æˆ Happy Birthday
            setTimeout(() => {
                updateState(STATE.TEXT);
            }, 1000);
        }

        function updateState(newState) {
            if (currentState === newState) return;
            currentState = newState;
            
            console.log("State Changed:", currentState);

            switch (currentState) {
                case STATE.CAKE:
                    generateCakeShape();
                    controls.autoRotate = true;
                    break;
                case STATE.EXPLODE:
                    generateExplodeShape();
                    controls.autoRotate = false; // æ‰‹åŠ¨æ§åˆ¶
                    break;
                case STATE.TEXT:
                    generateTextShape();
                    controls.autoRotate = true;
                    break;
                case STATE.PHOTO:
                    generateExplodeShape(); // èƒŒæ™¯æ˜¯æ•£å¼€çš„
                    break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
