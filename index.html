<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>The Golden Wish - Grand Master V8</title>
    <link rel="icon" href="data:,">
    <style>
        @import url('https://gs.jurieo.com/gemini/fonts-googleapis/css2?family=Cinzel:wght@700&family=Playfair+Display:ital@1&display=swap');
        body { margin: 0; overflow: hidden; background-color: #030303; font-family: 'Cinzel', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-input { 
            position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; 
            transform: scaleX(-1); opacity: 0.35; border: 2px solid rgba(255, 215, 0, 0.5); 
            border-radius: 15px; z-index: 2; pointer-events: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #ui-layer { 
            position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%); 
            z-index: 10; text-align: center; pointer-events: none; width: 100%; 
        }
        .upload-btn { 
            pointer-events: auto; background: linear-gradient(135deg, #ffd700 0%, #b8860b 100%); 
            border: none; color: #000; padding: 16px 50px; font-weight: bold; 
            cursor: pointer; border-radius: 4px; box-shadow: 0 10px 30px rgba(184, 134, 11, 0.3); 
            transition: 0.5s all; letter-spacing: 3px; font-family: 'Cinzel', serif;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .upload-btn:hover { background: #fff; color: #000; box-shadow: 0 0 50px rgba(255, 215, 0, 0.6); }
        #loading { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            color: #ffd700; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; background: #000; 
        }
        #gesture-hint { font-size: 20px; margin-top: 25px; color: #ffd700; opacity: 0.9; letter-spacing: 2px; }
        .loading-bar { width: 200px; height: 2px; background: #222; margin-top: 20px; position: relative; overflow: hidden; }
        .loading-bar-inner { width: 0%; height: 100%; background: #ffd700; transition: width 0.5s; }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.8",
            "@tweenjs/tween.js": "https://esm.sh/@tweenjs/tween.js@23.1.1"
        }
    }
    </script>
</head>
<body>

    <div id="loading">
        <div style="font-size: 32px; letter-spacing: 8px;">THE GOLDEN WISH</div>
        <div class="loading-bar"><div class="loading-bar-inner" id="loader"></div></div>
        <div class="status-text" id="loading-status" style="margin-top:10px; opacity:0.5;">Casting the Spells...</div>
    </div>

    <video id="video-input" autoplay playsinline></video>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <button class="upload-btn" onclick="document.getElementById('file-input').click()">UPLOAD MEMORIES</button>
        <div id="gesture-hint">WAKING UP THE SENSORS...</div>
    </div>

    <input type="file" id="file-input" multiple accept="image/*">

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';
        import TWEEN from '@tweenjs/tween.js';

        // --- Master Constants ---
        const PARTICLE_COUNT = 7500; // Increased for density
        const COLORS = {
            base: new THREE.Color(0xFFD700), // Gold
            pink: new THREE.Color(0xFF1493), // Deep Pink
            flameBase: new THREE.Color(0x0000FF), // Blue core
            flameMid: new THREE.Color(0xFF8C00), // Orange
            flameTop: new THREE.Color(0xFF0000)  // Red tip
        };

        let scene, camera, renderer, composer, controls, pMesh, dummy;
        let particles = [], textPoints = [], photoPlanes = [], photos = [];
        let handAI, faceAI, video, lastAiTime = 0;
        let state = 'assembled', isLock = false, isLit = true;

        async function init() {
            updateLoad(20, "Architecting Scene...");
            setupScene();
            updateLoad(50, "Synthesizing Particles...");
            createParticles();
            updateLoad(80, "Training Neural Networks...");
            await setupAI();
            setupVideo();
            setupEvents();
            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function updateLoad(val, txt) {
            document.getElementById('loader').style.width = val + "%";
            document.getElementById('loading-status').innerText = txt;
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x030303, 0.015);

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 18, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true, stencil: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.5, 0.8);
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.autoRotate = true; controls.autoRotateSpeed = 0.6;

            const spot = new THREE.PointLight(0xffaa00, 5, 40);
            spot.position.set(0, 8, 0); spot.name = "wick"; scene.add(spot);
            
            const amb = new THREE.AmbientLight(0xffffff, 0.2); scene.add(amb);
        }

        function createParticles() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800; canvas.height = 200;
            ctx.font = 'bold 80px "Cinzel"';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText("HAPPY BIRTHDAY", 400, 120);
            const data = ctx.getImageData(0, 0, 800, 200).data;
            for(let y=0; y<200; y+=4) {
                for(let x=0; x<800; x+=4) {
                    if(data[(y*800+x)*4+3] > 128) textPoints.push(new THREE.Vector3((x-400)*0.12, (100-y)*0.12 + 6, 0));
                }
            }

            const mat = new THREE.MeshPhongMaterial({ 
                color: 0xffffff, emissive: 0x111111, shininess: 200, transparent: true, opacity: 0.9 
            });
            pMesh = new THREE.InstancedMesh(new THREE.SphereGeometry(0.12, 8, 8), mat, PARTICLE_COUNT);
            dummy = new THREE.Object3D();

            for(let i=0; i<PARTICLE_COUNT; i++) {
                let cPos, sPos, tPos, color;
                let isFlame = false, flameGrade = 0;

                if (i < PARTICLE_COUNT * 0.6) { // Bottom Tier
                    const r = 4.5 + Math.random() * 2, a = Math.random() * Math.PI * 2, h = (Math.random()-0.5)*5;
                    cPos = new THREE.Vector3(r*Math.cos(a), h, r*Math.sin(a));
                    color = COLORS.base.clone().lerp(new THREE.Color(0xffffff), Math.random()*0.2);
                } else if (i < PARTICLE_COUNT * 0.92) { // Top Tier
                    const r = Math.random() * 3.5, a = Math.random() * Math.PI * 2, h = Math.random()*3.5 + 2.5;
                    cPos = new THREE.Vector3(r*Math.cos(a), h, r*Math.sin(a));
                    color = COLORS.pink.clone().lerp(new THREE.Color(0xffffff), Math.random()*0.3);
                } else { // Advanced Flame
                    flameGrade = Math.random();
                    const r = (1.0 - flameGrade) * 0.35, a = Math.random() * Math.PI * 2, h = flameGrade * 2.5 + 6;
                    cPos = new THREE.Vector3(r*Math.cos(a), h, r*Math.sin(a));
                    // Color Temp Gradient
                    if(flameGrade < 0.2) color = COLORS.flameBase.clone().lerp(COLORS.flameMid, flameGrade*5);
                    else color = COLORS.flameMid.clone().lerp(COLORS.flameTop, (flameGrade-0.2)*1.25);
                    isFlame = true;
                }

                sPos = new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*50, (Math.random()-0.5)*60);
                tPos = (i < textPoints.length * 4) ? textPoints[i % textPoints.length].clone().add(new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.6)) : sPos.clone();

                particles.push({ curr: cPos.clone(), cake: cPos, scatter: sPos, text: tPos, isFlame, flameGrade, baseCol: color, seed: Math.random()*20 });
                dummy.position.copy(cPos); dummy.updateMatrix();
                pMesh.setMatrixAt(i, dummy.matrix);
                pMesh.setColorAt(i, color);
            }
            scene.add(pMesh);

            for(let i=0; i<5; i++) {
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8, 5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide }));
                mesh.userData = { home: new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*30, (Math.random()-0.5)*20) };
                mesh.position.copy(mesh.userData.home);
                scene.add(mesh); photoPlanes.push(mesh);
            }
        }

        async function setupAI() {
            const vis = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm");
            handAI = await HandLandmarker.createFromOptions(vis, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            faceAI = await FaceLandmarker.createFromOptions(vis, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`, delegate: "GPU" },
                outputFaceBlendshapes: true, runningMode: "VIDEO", numFaces: 1
            });
        }

        function transformTo(ns) {
            if (isLock || state === ns) return;
            isLock = true; state = ns;
            
            const duration = ns === 'scattered' ? 1000 : 1800;
            const wick = scene.getObjectByName("wick");

            if (ns === 'assembled') {
                isLit = true; new TWEEN.Tween(wick).to({intensity: 5}, 1000).start(); 
                controls.autoRotate = true;
                document.getElementById('gesture-hint').innerText = "BLOW OR PINCH THE LIGHT";
            } else {
                isLit = false; new TWEEN.Tween(wick).to({intensity: 0.1}, 400).start();
                controls.autoRotate = false;
                if(ns === 'text') new TWEEN.Tween(scene.rotation).to({y: 0}, 1200).easing(TWEEN.Easing.Cubic.Out).start();
                document.getElementById('gesture-hint').innerText = ns === 'text' ? "WISH GRANTED" : "FRAGMENTS OF TIME";
            }

            particles.forEach((p, i) => {
                const target = ns === 'assembled' ? p.cake : (ns === 'text' ? p.text : p.scatter);
                if (p.isFlame) pMesh.setColorAt(i, ns === 'assembled' ? p.baseCol : new THREE.Color(0x110500));
                
                new TWEEN.Tween(p.curr).to({x: target.x, y: target.y, z: target.z}, duration + Math.random()*600)
                    .easing(ns === 'scattered' ? TWEEN.Easing.Back.Out : TWEEN.Easing.Exponential.InOut)
                    .onUpdate(() => {
                        dummy.position.copy(p.curr); dummy.updateMatrix();
                        pMesh.setMatrixAt(i, dummy.matrix);
                    }).start();
            });
            pMesh.instanceColor.needsUpdate = true;

            photoPlanes.forEach(m => {
                new TWEEN.Tween(m.material).to({opacity: (ns === 'scattered' && photos.length > 0) ? 0.95 : 0}, 1000).start();
            });

            setTimeout(() => isLock = false, duration + 600);
        }

        function predict() {
            const now = performance.now();
            if (now - lastAiTime > 100 && !isLock) {
                lastAiTime = now;
                const hRes = handAI.detectForVideo(video, now);
                if (hRes.landmarks.length > 0) {
                    const l = hRes.landmarks[0];
                    const dist = Math.hypot(l[8].x-l[0].x, l[8].y-l[0].y);
                    if (dist > 0.45 && state === 'assembled') transformTo('scattered');
                    if (dist < 0.2 && state !== 'assembled') transformTo('assembled');
                }
                const fRes = faceAI.detectForVideo(video, now);
                if (fRes.faceBlendshapes.length > 0) {
                    const s = fRes.faceBlendshapes[0].categories.find(c => c.categoryName === 'mouthPucker').score;
                    if (s > 0.65 && state === 'assembled') transformTo('text');
                }
            }
            requestAnimationFrame(predict);
        }

        function setupVideo() {
            video = document.getElementById('video-input');
            navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
                video.srcObject = s;
                video.onloadeddata = () => predict();
            });
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            document.getElementById('file-input').onchange = (e) => {
                const loader = new THREE.TextureLoader();
                for(let i=0; i<Math.min(e.target.files.length, 5); i++) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const tex = loader.load(ev.target.result);
                        tex.colorSpace = THREE.SRGBColorSpace;
                        photos[i] = tex; photoPlanes[i].material.map = tex; photoPlanes[i].material.needsUpdate = true;
                    };
                    reader.readAsDataURL(e.target.files[i]);
                }
            };
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update(); controls.update();
            const t = Date.now() * 0.0015;

            if (isLit && state === 'assembled') {
                particles.forEach((p, i) => {
                    if (p.isFlame) {
                        const freq = 3.0 + p.flameGrade * 2;
                        const drift = Math.sin(t * freq + p.seed) * (p.flameGrade * 0.2);
                        dummy.position.set(p.curr.x + drift, p.curr.y + Math.sin(t*10)*0.02, p.curr.z + drift);
                        dummy.updateMatrix();
                        pMesh.setMatrixAt(i, dummy.matrix);
                    }
                });
                pMesh.instanceMatrix.needsUpdate = true;
                scene.getObjectByName("wick").intensity = 5 + Math.sin(t*8) * 0.5;
            } else if (state === 'text') {
                // 文字态微震荡 - 增加灵动感
                particles.forEach((p, i) => {
                    if (i < textPoints.length * 4) {
                        const vib = Math.sin(t * 5 + i) * 0.03;
                        dummy.position.set(p.curr.x + vib, p.curr.y + vib, p.curr.z + vib);
                        dummy.updateMatrix();
                        pMesh.setMatrixAt(i, dummy.matrix);
                    }
                });
                pMesh.instanceMatrix.needsUpdate = true;
            }
            composer.render();
        }

        init();
    </script>
</body>
</html>
