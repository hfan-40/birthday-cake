<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rose Gold Ultimate 666 - Instanced Pro</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a080a; font-family: 'Times New Roman', serif; }
        #loader { 
            position: fixed; inset: 0; background: #000; z-index: 100; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            color: #FFB6C1; letter-spacing: 5px; transition: opacity 0.8s; 
        }
        .spinner { width: 50px; height: 50px; border: 2px solid rgba(255,182,193,0.1); border-top-color: #D4AF37; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        #ui-hint { position: absolute; bottom: 40px; width: 100%; text-align: center; color: #D4AF37; pointer-events: none; z-index: 10; text-shadow: 0 0 20px rgba(0,0,0,0.9); font-size: 13px; letter-spacing: 2px; text-transform: uppercase; }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="status">INSTANCING GPU MEMORY...</div>
    </div>

    <div id="ui-hint">
        Mirror Control: üëã Rotate | üëê Magic Burst | üòó Blow Out
    </div>

    <video id="webcam" style="display:none;" playsinline></video>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';

        const CONFIG = {
            total: 666,
            colors: {
                rose: new THREE.Color(0xFFB6C1),  // Á≤æËá¥Áé´Áë∞Á≤â
                ivory: new THREE.Color(0xFFFFF5), // ÊöñË±°ÁâôÁôΩ
                gold: new THREE.Color(0xD4AF37)   // Áª∏ÁºéÈáë
            },
            particleScale: 1.4
        };

        let scene, camera, renderer, composer, bloomPass, mainGroup;
        let handLandmarker, faceLandmarker, video;
        let iMeshes = [], particleData = [];
        let flame, candle;
        let state = { rotY: 0, explode: 0, blown: false, frame: 0 };
        const dummy = new THREE.Object3D();

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 18, 70);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping; // Êõ¥ÊúâÁîµÂΩ±Ë¥®ÊÑüÁöÑËâ≤Ë∞ÉÊò†Â∞Ñ
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            const pmrem = new THREE.PMREMGenerator(renderer);
            scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

            const renderPass = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            setupInstancedCake();
            await setupAI();

            document.getElementById('loader').style.opacity = 0;
            animate();
        }

        function setupInstancedCake() {
            // ÈóÆÈ¢ò‰∏ÄÔºöÂá†‰Ωï‰ΩìÈáçÊûÑ
            const geos = [
                new THREE.SphereGeometry(0.6, 24, 24),
                new THREE.BoxGeometry(0.9, 0.9, 0.9),
                new THREE.CylinderGeometry(0.2, 0.2, 2.2, 12),
                new THREE.ConeGeometry(0.8, 1.5, 3) 
            ];

            // ÊùêË¥®ÔºöÁâ©ÁêÜÈ´òÁ∫ßÊÑü
            const baseMat = new THREE.MeshPhysicalMaterial({ 
                metalness: 0.2, roughness: 0.15, clearcoat: 1.0, envMapIntensity: 1.5 
            });

            // ‰∏∫ 4 ÁßçÂΩ¢Áä∂ÂàõÂª∫ÂÆû‰æãÂåñÁΩëÊ†º
            const countPerGeo = Math.ceil(CONFIG.total / geos.length);
            geos.forEach((geo, gIdx) => {
                const im = new THREE.InstancedMesh(geo, baseMat.clone(), countPerGeo);
                im.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                mainGroup.add(im);
                iMeshes.push(im);
            });

            // È¢ÑËÆ°ÁÆóÂàÜÂ∏É
            for (let i = 0; i < CONFIG.total; i++) {
                const gIdx = i % geos.length;
                const iIdx = Math.floor(i / geos.length);
                const isTop = i > CONFIG.total * 0.45;
                const isBow = i < 60; // Ëù¥Ëù∂ÁªìÁ≤íÂ≠êÊï∞

                let color = isTop ? CONFIG.colors.rose : CONFIG.colors.ivory;
                if (Math.random() > 0.82 || isBow) color = CONFIG.colors.gold;

                const pos = new THREE.Vector3();
                if (isBow) {
                    // ÈóÆÈ¢ò‰∫åÔºöËù¥Ëù∂ÁªìÁÆóÊ≥ï (Êï∞Â≠¶Ê®°ÊãüËù∂ÂΩ¢Á∫ø)
                    const side = i % 2 === 0 ? 1 : -1;
                    const t = (i / 60) * Math.PI * 2;
                    pos.set(
                        side * (12 + Math.sin(t) * 3), 
                        -4 + Math.cos(t) * 4, 
                        16 + Math.sin(t * 2) * 2
                    );
                } else {
                    const r = isTop ? 13 + Math.random() * 3 : 18 + Math.random() * 3;
                    const theta = Math.random() * Math.PI * 2;
                    pos.set(Math.cos(theta) * r, isTop ? 6 + Math.random() * 8 : -8 + Math.random() * 14, Math.sin(theta) * r);
                }

                particleData.push({
                    gIdx, iIdx,
                    pos: pos.clone(),
                    origin: pos.clone(),
                    rot: new THREE.Euler(Math.random() * 6, Math.random() * 6, Math.random() * 6),
                    vRot: new THREE.Vector3(Math.random() * 0.02, Math.random() * 0.02, Math.random() * 0.02)
                });

                iMeshes[gIdx].setColorAt(iIdx, color);
            }

            // Ëú°ÁÉõ
            candle = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 10, 20), baseMat.clone());
            candle.position.set(0, 18, 0);
            candle.material.color.copy(CONFIG.colors.ivory);
            mainGroup.add(candle);

            // ÈóÆÈ¢ò‰∏âÔºöÁÅ´ÁÑ∞ÂΩ¢Áä∂ (Lathe)
            const points = [];
            for (let i = 0; i < 10; i++) {
                points.push(new THREE.Vector2(Math.sin(i * 0.3) * 0.6 * (1 - i / 10), i * 0.4));
            }
            const fGeo = new THREE.LatheGeometry(points, 20);
            const fMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xff4500, emissiveIntensity: 6 });
            flame = new THREE.Mesh(fGeo, fMat);
            flame.position.set(0, 5.5, 0);
            candle.add(flame);
        }

        async function setupAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", outputFaceBlendshapes: true
            });
            video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
            video.srcObject = stream;
            video.play();
            return new Promise(res => video.onloadeddata = res);
        }

        function animate() {
            state.frame++;
            const time = performance.now() * 0.001;
            requestAnimationFrame(animate);

            if (video.readyState >= 2) {
                const hRes = handLandmarker.detectForVideo(video, performance.now());
                const fRes = faceLandmarker.detectForVideo(video, performance.now());

                // ‰∫§‰∫í‰∏ÄÔºöÂπ≥ÊªëÊóãËΩ¨
                if (hRes.landmarks.length > 0) {
                    const x = hRes.landmarks[0][9].x;
                    state.rotY = THREE.MathUtils.lerp(state.rotY, (x - 0.5) * 4, 0.1);
                    
                    // ‰∫§‰∫í‰∫åÔºöÈ≠îÊ≥ïÁàÜÂèë
                    if (hRes.landmarks.length === 2) {
                        const d = Math.hypot(hRes.landmarks[0][9].x - hRes.landmarks[1][9].x, hRes.landmarks[0][9].y - hRes.landmarks[1][9].y);
                        state.explode = THREE.MathUtils.lerp(state.explode, d > 0.55 ? 1 : 0, 0.1);
                    }
                }

                // ‰∫§‰∫í‰∏âÔºöÂêπÁÅ≠
                if (fRes.faceBlendshapes.length > 0) {
                    const pucker = fRes.faceBlendshapes[0].categories.find(c => c.categoryName === 'mouthPucker').score;
                    if (pucker > 0.5) state.blown = true;
                }
            }

            mainGroup.rotation.y = state.rotY;

            // ÈóÆÈ¢ò‰∏âÔºöÁÅ´ÁÑ∞ÊñπÂêëË°•ÂÅø (ÂÖ≥ÈîÆÔºö‰ΩøÁî®‰∏ñÁïåÂõõÂÖÉÊï∞ÂèçËΩ¨)
            if (flame) {
                flame.quaternion.copy(mainGroup.quaternion).invert();
                flame.scale.setScalar(1 + Math.sin(time * 20) * 0.1);
                if (state.blown) {
                    flame.visible = false;
                    candle.material.emissiveIntensity = 0;
                }
            }

            // Êõ¥Êñ∞ÂÆû‰æãÂåñÁ≤íÂ≠ê
            particleData.forEach((p, idx) => {
                const { gIdx, iIdx, origin, rot, vRot } = p;
                
                // È≠îÊ≥ïÂä®ÂäõÂ≠¶ÔºöÁàÜÁÇ∏ + ÂëºÂê∏ÊµÆÂä®
                const noise = Math.sin(time * 2 + idx) * 0.5;
                const explodePower = state.explode * 30;
                
                dummy.position.x = origin.x + (origin.x * state.explode * 1.5) + Math.cos(idx) * noise;
                dummy.position.y = origin.y + (state.explode * 20) + noise;
                dummy.position.z = origin.z + (origin.z * state.explode * 1.5) + Math.sin(idx) * noise;

                rot.x += vRot.x; rot.y += vRot.y;
                dummy.rotation.copy(rot);

                const s = CONFIG.particleScale * (1 - state.explode * 0.3);
                dummy.scale.set(s, s, s);
                
                dummy.updateMatrix();
                iMeshes[gIdx].setMatrixAt(iIdx, dummy.matrix);
            });

            iMeshes.forEach(im => im.instanceMatrix.needsUpdate = true);
            
            // ËæâÂÖâÂä®ÊÄÅ
            if (!state.blown) {
                bloomPass.strength = 1.2 + Math.sin(time * 3) * 0.3 + (state.explode * 2);
            }

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
