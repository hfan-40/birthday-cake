<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 魔法生日蛋糕</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            user-select: none;
            font-size: 18px;
            letter-spacing: 2px;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">加载资源中...</div>
    <div id="canvas-container"></div>
    <div id="ui">点击屏幕 / 张开手掌 许愿</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 配置参数 ---
        const CONFIG = {
            count: 2000,          // 粒子数量
            cakeRadius: 2.5,
            cakeHeight: 4.0,
            scatterRadius: 12.0,
            colors: ['#FFD700', '#FF3366', '#33CCFF', '#FFFFFF', '#FFAA00']
        };

        // --- Shader (视觉核心) ---
        // 这里的 Shader 与之前的完全一致，负责物理渲染和形状变换
        const vertexShader = `
            precision highp float;
            uniform float uTime;
            uniform float uExpansion; // 0.0 = 蛋糕, 1.0 = 散开

            attribute vec3 aPosCake;
            attribute vec3 aPosScatter;
            attribute float aSpeed;
            
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            // 缓动函数：BackOut (让炸开有弹射感)
            float easeOutBack(float x) {
                float c1 = 1.70158;
                float c3 = c1 + 1.0;
                return 1.0 + c3 * pow(x - 1.0, 3.0) + c1 * pow(x - 1.0, 2.0);
            }

            void main() {
                vNormal = normalize(normalMatrix * normal);
                vColor = instanceColor;

                // 状态混合
                float t = smoothstep(0.0, 1.0, uExpansion);
                float morphFactor = mix(t, easeOutBack(t), 0.6); 
                
                vec3 targetPos = mix(aPosCake, aPosScatter, morphFactor);

                // 散开时的漂浮噪点
                if (uExpansion > 0.01) {
                    targetPos.x += sin(uTime * aSpeed + targetPos.y) * 0.2 * uExpansion;
                    targetPos.y += cos(uTime * aSpeed * 0.8 + targetPos.x) * 0.2 * uExpansion;
                }

                vec4 mvPosition = modelViewMatrix * vec4(targetPos, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            precision highp float;
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);
                vec3 lightDir = normalize(vec3(0.5, 0.8, 0.5)); 
                
                // 漫反射
                float diff = max(dot(normal, lightDir), 0.0);
                
                // 高光 (光泽感)
                vec3 halfwayDir = normalize(lightDir + viewDir);
                float spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);
                
                // 边缘光
                float rim = 1.0 - max(dot(viewDir, normal), 0.0);
                rim = pow(rim, 3.0) * 0.5;

                // 组合
                vec3 ambient = vec3(0.1);
                vec3 finalColor = vColor * (ambient + diff) + vec3(0.8) * spec + vec3(0.3) * rim;

                // Tone Mapping (防止过曝)
                finalColor = finalColor / (finalColor + vec3(1.0));
                finalColor = pow(finalColor, vec3(1.0 / 2.2));

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- 初始化场景 ---
        const container = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#050505');

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 18);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;

        // --- 生成粒子数据 ---
        const geometry = new THREE.SphereGeometry(0.12, 16, 16); // 基础球体
        const instancedGeo = new THREE.InstancedBufferGeometry();
        instancedGeo.index = geometry.index;
        instancedGeo.attributes.position = geometry.attributes.position;
        instancedGeo.attributes.normal = geometry.attributes.normal;
        instancedGeo.attributes.uv = geometry.attributes.uv;

        const count = CONFIG.count;
        const posCake = new Float32Array(count * 3);
        const posScatter = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        const speeds = new Float32Array(count);

        const palette = CONFIG.colors.map(c => new THREE.Color(c));

        for (let i = 0; i < count; i++) {
            // A. 蛋糕位置
            const r = Math.random() * CONFIG.cakeRadius;
            const theta = i * 0.5;
            const y = (i / count) * CONFIG.cakeHeight - (CONFIG.cakeHeight / 2);
            // 修正圆柱表面
            const rSurface = CONFIG.cakeRadius * (1.0 - (y + 2.0)/8.0);
            
            posCake[i*3] = Math.cos(theta) * rSurface;
            posCake[i*3+1] = y;
            posCake[i*3+2] = Math.sin(theta) * rSurface;

            // B. 散开位置
            const phi = Math.acos(-1 + (2 * i) / count);
            const sq = Math.sqrt(count * Math.PI * phi);
            const rScatter = CONFIG.scatterRadius;
            
            posScatter[i*3] = rScatter * Math.cos(sq) * Math.sin(phi);
            posScatter[i*3+1] = rScatter * Math.sin(sq) * Math.sin(phi);
            posScatter[i*3+2] = rScatter * Math.cos(phi);

            // C. 颜色
            const color = palette[Math.floor(Math.random() * palette.length)];
            colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
            
            speeds[i] = Math.random() * 0.5 + 0.5;
        }

        instancedGeo.setAttribute('aPosCake', new THREE.InstancedBufferAttribute(posCake, 3));
        instancedGeo.setAttribute('aPosScatter', new THREE.InstancedBufferAttribute(posScatter, 3));
        instancedGeo.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(colors, 3));
        instancedGeo.setAttribute('aSpeed', new THREE.InstancedBufferAttribute(speeds, 1));
        instancedGeo.instanceCount = count;

        // --- 材质 ---
        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uExpansion: { value: 0 }
            }
        });

        const mesh = new THREE.Mesh(instancedGeo, material);
        scene.add(mesh);

        // --- 简单的照片墙 (用 Sprite 模拟) ---
        const photoGroup = new THREE.Group();
        // 这里使用 picsum 作为占位图，实际使用时请替换为你的图片URL
        const photoUrls = [
            'https://picsum.photos/id/1011/200/300',
            'https://picsum.photos/id/1015/200/300',
            'https://picsum.photos/id/1025/200/300',
            'https://picsum.photos/id/1027/200/300'
        ];
        
        const textureLoader = new THREE.TextureLoader();
        photoUrls.forEach((url, i) => {
            textureLoader.load(url, (tex) => {
                const aspect = tex.image.width / tex.image.height;
                const photoGeo = new THREE.PlaneGeometry(1.5, 1.5 / aspect);
                const photoMat = new THREE.MeshBasicMaterial({ 
                    map: tex, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0 
                });
                const photo = new THREE.Mesh(photoGeo, photoMat);
                
                // 随机位置
                photo.position.set(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 6
                );
                photo.rotation.z = (Math.random() - 0.5) * 0.5;
                photoGroup.add(photo);
            });
        });
        scene.add(photoGroup);
        document.getElementById('loading').style.display = 'none';

        // --- 动画循环与交互逻辑 ---
        
        // 状态变量
        let state = {
            targetExpansion: 0, // 0 = 蛋糕, 1 = 散开
            currentExpansion: 0
        };

        // 交互：点击切换
        const toggleState = () => {
            state.targetExpansion = state.targetExpansion === 0 ? 1 : 0;
            
            // UI 更新
            const uiText = state.targetExpansion === 0 ? "点击屏幕 / 张开手掌 许愿" : "点击屏幕 / 握拳 复原蛋糕";
            document.getElementById('ui').innerText = uiText;
            
            // 散开时自动旋转，蛋糕时停止
            controls.autoRotate = state.targetExpansion === 1;
        };

        window.addEventListener('mousedown', toggleState);
        window.addEventListener('touchstart', toggleState);

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            
            // 1. 简单的弹簧物理模拟 (Lerp)
            // 让 current 数值平滑地追赶 target 数值
            const lerpSpeed = 0.05;
            state.currentExpansion += (state.targetExpansion - state.currentExpansion) * lerpSpeed;

            // 2. 更新 Shader Uniforms
            material.uniforms.uTime.value = time;
            material.uniforms.uExpansion.value = state.currentExpansion;

            // 3. 更新照片墙 (透明度和缩放)
            // 只有当散开程度 > 0.8 时，照片才完全显现
            const photoOpacity = Math.max(0, (state.currentExpansion - 0.5) * 2);
            photoGroup.children.forEach(photo => {
                photo.material.opacity = photoOpacity;
                // 简单的缩放进场
                const scale = 0.5 + 0.5 * photoOpacity;
                photo.scale.set(scale, scale, scale);
                // 漂浮动画
                photo.position.y += Math.sin(time + photo.position.x) * 0.002;
            });

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
