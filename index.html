<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luxury Birthday Magic - Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background: #080808; font-family: 'Times New Roman', serif; }
        
        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 5vh; }
        
        h1 {
            color: #f0e6d2;
            font-size: 2.5rem;
            letter-spacing: 0.5rem;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
            margin-bottom: 10px;
            opacity: 0;
            animation: fadeIn 2s forwards 1s;
        }

        .hint {
            color: #d4af37;
            font-size: 0.9rem;
            border: 1px solid rgba(212, 175, 55, 0.3);
            padding: 8px 20px;
            border-radius: 20px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            opacity: 0;
            animation: fadeIn 2s forwards 2s;
        }

        /* åŠ è½½åŠ¨ç”» */
        #loader { position: fixed; inset: 0; background: #000; z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 1s ease; }
        .circle { width: 50px; height: 50px; border: 2px solid rgba(212, 175, 55, 0.2); border-top: 2px solid #d4af37; border-radius: 50%; animation: spin 1s infinite linear; }
        .loading-text { color: #d4af37; margin-top: 15px; font-size: 12px; letter-spacing: 2px; }

        /* æ‘„åƒå¤´é¢„è§ˆ (é•œåƒ) */
        #webcam-preview { 
            position: absolute; bottom: 20px; right: 20px; width: 120px; height: 90px; 
            border: 1px solid #d4af37; border-radius: 8px; z-index: 20; 
            transform: scaleX(-1); opacity: 0.5; transition: opacity 0.3s;
        }
        #webcam-preview:hover { opacity: 1; }

        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { to { opacity: 1; } }
    </style>
</head>
<body>

    <div id="loader">
        <div class="circle"></div>
        <div class="loading-text" id="load-status">INITIALIZING MAGIC...</div>
    </div>

    <div id="ui-layer">
        <h1 id="main-title">Grand Celebration</h1>
        <div class="hint">ğŸ– å¼ å¼€: æ•£æ”¾ | âœŠ æ¡æ‹³: èšåˆ | ğŸ˜— å˜Ÿå˜´: è®¸æ„¿(å¹æ°”)</div>
    </div>

    <video id="webcam" autoplay playsinline style="display:none;"></video>
    <canvas id="webcam-preview"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';

        // --- é…ç½® ---
        const CONFIG = {
            count: 5000,
            colors: { gold: 0xffd700, rose: 0xffb7c5, white: 0xffffff },
            blowThreshold: 0.5, // å˜Ÿå˜´é˜ˆå€¼
            blowDuration: 15,   // éœ€è¦æŒç»­å¤šå°‘å¸§æ‰è§¦å‘ï¼ˆé˜²æŠ–ï¼‰
        };

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer, particles;
        let handLandmarker, faceLandmarker, video;
        let puckerCounter = 0; // å¹æ°”è®¡æ•°å™¨
        
        // çŠ¶æ€æœº
        let state = {
            mode: 'CAKE', // CAKE, SCATTER, TEXT
            isBlown: false,
            rotation: 0,
            mouse: new THREE.Vector2()
        };

        // ç²’å­æ•°æ®
        const particleData = {
            cake: new Float32Array(CONFIG.count * 3),
            text: new Float32Array(CONFIG.count * 3),
            current: new Float32Array(CONFIG.count * 3),
            speeds: new Float32Array(CONFIG.count), // ç‹¬ç«‹é€Ÿåº¦
            noiseOffsets: new Float32Array(CONFIG.count) // å™ªæ³¢åç§»
        };

        async function init() {
            initThree();
            generateCakeShape();
            generateTextShape();
            
            try {
                await initAI();
                document.getElementById('load-status').innerText = "READY";
            } catch (err) {
                console.warn("AI Init Failed, switching to Mouse Mode.", err);
                document.querySelector('.hint').innerText = "ğŸ–±ï¸ ç§»åŠ¨: æ—‹è½¬ | ğŸ–±ï¸ ç‚¹å‡»: å¹ç­èœ¡çƒ›";
                setupMouseFallback();
            }

            // éšè— Loading
            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 1000);

            animate();
        }

        // --- 1. Three.js åœºæ™¯åˆå§‹åŒ– ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x080808, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 40);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // åå¤„ç† (Bloom è¾‰å…‰)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.85);
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            const geometry = new THREE.BufferGeometry();
            const colors = [];
            const sizes = [];
            
            for (let i = 0; i < CONFIG.count; i++) {
                particleData.current[i*3] = (Math.random()-0.5) * 100;
                particleData.current[i*3+1] = (Math.random()-0.5) * 100;
                particleData.current[i*3+2] = (Math.random()-0.5) * 100;

                particleData.speeds[i] = 0.02 + Math.random() * 0.05;
                particleData.noiseOffsets[i] = Math.random() * 100;

                // é¢œè‰²åˆ†é…ï¼š60% ç«ç‘°ç²‰, 30% é‡‘è‰², 10% ç™½è‰²
                const r = Math.random();
                const color = new THREE.Color(r > 0.4 ? CONFIG.colors.rose : (r > 0.1 ? CONFIG.colors.gold : CONFIG.colors.white));
                colors.push(color.r, color.g, color.b);
                
                // å¤§å°éšæœº
                sizes.push(r > 0.1 ? 0.15 : 0.08); 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(particleData.current, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            // è‡ªå®šä¹‰æè´¨ (åœ†å½¢ç²’å­)
            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize);
        }

        // --- 2. å½¢çŠ¶ç”Ÿæˆç®—æ³• ---
        function generateCakeShape() {
            for (let i = 0; i < CONFIG.count; i++) {
                const i3 = i * 3;
                const angle = Math.random() * Math.PI * 2;
                let r, x, y, z;

                if (i < CONFIG.count * 0.6) {
                    // åº•å±‚
                    r = 8 + Math.random() * 1.5;
                    y = Math.random() * 6 - 4;
                } else {
                    // é¡¶å±‚ + å¥¶æ²¹æµæ·Œ
                    r = 5 + Math.random() * 1.2;
                    y = Math.random() * 5 + 2;
                    // æ¨¡æ‹Ÿæµæ·Œçš„å¥¶æ²¹è¾¹
                    if (Math.random() > 0.8) y -= Math.sin(angle * 5) * 1.5; 
                }
                
                x = Math.cos(angle) * r;
                z = Math.sin(angle) * r;

                particleData.cake[i3] = x;
                particleData.cake[i3+1] = y;
                particleData.cake[i3+2] = z;
            }
        }

        function generateTextShape() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = '900 60px "Times New Roman"';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('HAPPY BIRTHDAY', 256, 64);

            const imgData = ctx.getImageData(0, 0, 512, 128).data;
            const validPixels = [];

            for (let y = 0; y < 128; y += 2) {
                for (let x = 0; x < 512; x += 2) {
                    if (imgData[(y * 512 + x) * 4] > 128) {
                        validPixels.push({
                            x: (x - 256) * 0.15,
                            y: (64 - y) * 0.15 + 5 // æŠ¬é«˜ä¸€ç‚¹
                        });
                    }
                }
            }

            for (let i = 0; i < CONFIG.count; i++) {
                const i3 = i * 3;
                // å¦‚æœç²’å­å¤šäºåƒç´ ï¼Œéšæœºåˆ†é…åˆ°æŸä¸ªåƒç´ ç‚¹
                const pixel = validPixels[i % validPixels.length];
                particleData.text[i3] = pixel.x;
                particleData.text[i3+1] = pixel.y;
                particleData.text[i3+2] = (Math.random() - 0.5) * 2; // ç»™æ–‡å­—ä¸€ç‚¹åšåº¦
            }
        }

        // --- 3. AI åˆå§‹åŒ– (ä¸²è¡ŒåŠ è½½) ---
        async function initAI() {
            document.getElementById('load-status').innerText = "LOADING VISION CORE...";
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });

            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", outputFaceBlendshapes: true
            });

            video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            
            // é¢„è§ˆ canvas
            video.addEventListener('loadeddata', () => {
                const pc = document.getElementById('webcam-preview');
                pc.width = video.videoWidth;
                pc.height = video.videoHeight;
            });
        }

        function setupMouseFallback() {
            window.addEventListener('mousemove', (e) => {
                state.rotation = (e.clientX / window.innerWidth - 0.5) * 4;
            });
            window.addEventListener('click', () => {
                if (!state.isBlown) triggerBlow();
            });
        }

        function triggerBlow() {
            state.isBlown = true;
            state.mode = 'TEXT';
            const title = document.getElementById('main-title');
            title.style.opacity = 0;
            setTimeout(() => {
                title.innerText = "Make A Wish!";
                title.style.color = "#fff";
                title.style.opacity = 1;
            }, 500);
        }

        // --- 4. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            // --- AI æ£€æµ‹é€»è¾‘ ---
            if (video && video.readyState >= 2) {
                // ç»˜åˆ¶é¢„è§ˆ
                const pc = document.getElementById('webcam-preview');
                pc.getContext('2d').drawImage(video, 0, 0, pc.width, pc.height);

                // æ‰‹åŠ¿
                const handRes = handLandmarker.detectForVideo(video, performance.now());
                if (handRes.landmarks.length > 0) {
                    const lm = handRes.landmarks[0];
                    const spread = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    if (!state.isBlown) {
                        state.mode = spread > 0.45 ? 'SCATTER' : 'CAKE';
                    }
                    state.rotation = THREE.MathUtils.lerp(state.rotation, (lm[9].x - 0.5) * 5, 0.1);
                }

                // è„¸éƒ¨ (å˜Ÿå˜´æ£€æµ‹)
                const faceRes = faceLandmarker.detectForVideo(video, performance.now());
                if (faceRes.faceBlendshapes.length > 0 && !state.isBlown) {
                    const pucker = faceRes.faceBlendshapes[0].categories.find(c => c.categoryName === 'mouthPucker').score;
                    if (pucker > CONFIG.blowThreshold) {
                        puckerCounter++;
                        if (puckerCounter > CONFIG.blowDuration) triggerBlow();
                    } else {
                        puckerCounter = Math.max(0, puckerCounter - 1);
                    }
                }
            }

            // --- ç²’å­ç‰©ç†æ¨¡æ‹Ÿ ---
            const pos = particles.geometry.attributes.position.array;
            
            // ç¡®å®šç›®æ ‡çŠ¶æ€
            let targetBuffer;
            if (state.mode === 'TEXT') targetBuffer = particleData.text;
            else if (state.mode === 'CAKE') targetBuffer = particleData.cake;
            
            for (let i = 0; i < CONFIG.count; i++) {
                const i3 = i * 3;
                
                if (state.mode === 'SCATTER') {
                    // æ•£å¼€æ¨¡å¼ï¼šåŸºäºå™ªæ³¢çš„æ¼‚æµ®
                    pos[i3] += Math.sin(time + particleData.noiseOffsets[i]) * 0.05;
                    pos[i3+1] += Math.cos(time + particleData.noiseOffsets[i] * 0.5) * 0.05;
                    pos[i3+2] += Math.sin(time * 0.5 + particleData.noiseOffsets[i]) * 0.05;
                } else {
                    // èšåˆ/æ–‡å­—æ¨¡å¼ï¼šé£å‘ç›®æ ‡
                    const tx = targetBuffer[i3];
                    const ty = targetBuffer[i3+1];
                    const tz = targetBuffer[i3+2];
                    
                    // å¢åŠ èºæ—‹é£è¡Œæ•ˆæœ (Curl Noise æ¨¡æ‹Ÿ)
                    const speed = state.isBlown ? 0.04 : 0.08; // å¹æ°”æ—¶é£å¾—æ…¢ä¸€ç‚¹ï¼Œæ›´å”¯ç¾
                    
                    pos[i3] += (tx - pos[i3]) * speed;
                    pos[i3+1] += (ty - pos[i3+1]) * speed;
                    pos[i3+2] += (tz - pos[i3+2]) * speed;

                    // å¢åŠ ä¸€ç‚¹å¾®å¼±çš„æ³¢åŠ¨ï¼Œè®©æ–‡å­—å’Œè›‹ç³•çœ‹èµ·æ¥æ˜¯â€œæ´»â€çš„
                    if (Math.abs(tx - pos[i3]) < 0.1) {
                        pos[i3] += Math.sin(time * 2 + particleData.noiseOffsets[i]) * 0.01;
                        pos[i3+1] += Math.cos(time * 3 + particleData.noiseOffsets[i]) * 0.01;
                    }
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, state.rotation, 0.05);

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
