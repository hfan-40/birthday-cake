<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>The Golden Wish - Grand Master V11</title>
    <link rel="icon" href="data:,">
    <style>
        @import url('https://gs.jurieo.com/gemini/fonts-googleapis/css2?family=Cinzel:wght@700&display=swap');
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Cinzel', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; }
        #video-input { 
            position: absolute; top: 20px; right: 20px; width: 140px; height: 105px; 
            transform: scaleX(-1); opacity: 0.25; border: 1px solid #ffd700; 
            border-radius: 12px; z-index: 2; pointer-events: none;
        }
        #ui-layer { 
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); 
            z-index: 10; text-align: center; pointer-events: none; width: 100%; 
        }
        .upload-btn { 
            pointer-events: auto; background: linear-gradient(135deg, #ffd700, #b8860b); 
            color: #000; padding: 12px 40px; font-weight: 800; cursor: pointer; 
            border-radius: 4px; border: none; transition: 0.3s; letter-spacing: 2px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        #loading { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            color: #ffd700; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; background: #000; 
        }
        #gesture-hint { font-size: 16px; margin-top: 25px; color: #ffd700; letter-spacing: 2px; }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.8",
            "@tweenjs/tween.js": "https://esm.sh/@tweenjs/tween.js@23.1.1"
        }
    }
    </script>
</head>
<body>

    <div id="loading">
        <div style="font-size: 24px; letter-spacing: 4px;">REFINING REALITY...</div>
        <div id="loading-status" style="margin-top:10px; opacity:0.5; font-size:12px;">Synthesizing Light...</div>
    </div>

    <video id="video-input" autoplay playsinline></video>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <button class="upload-btn" onclick="document.getElementById('file-input').click()">UPLOAD MEMORIES</button>
        <div id="gesture-hint">Awakening Vision...</div>
    </div>

    <input type="file" id="file-input" multiple accept="image/*">

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';
        import TWEEN from '@tweenjs/tween.js';

        const PARTICLE_COUNT = 6800;
        let scene, camera, renderer, composer, controls, pMesh, dummy;
        let particles = [], textPoints = [], photoPlanes = [], photos = [];
        let handAI, faceAI, video, lastAiTime = 0;
        let state = 'assembled', isLock = false, isLit = true;
        let gestureTimer = 0, targetState = 'assembled';

        async function init() {
            setupScene();
            createParticles();
            await setupAI();
            setupVideo();
            setupEvents();
            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 15, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.4;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.8);
            bloom.threshold = 0.25; bloom.strength = 1.0; bloom.radius = 0.55;

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.autoRotate = true; controls.autoRotateSpeed = 0.4;

            const spot = new THREE.PointLight(0xff9900, 8, 40);
            spot.position.set(0, 7, 0); spot.name = "wick"; scene.add(spot);
            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
        }

        function createParticles() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 600; canvas.height = 150;
            ctx.font = 'bold 64px "Cinzel"';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText("HAPPY BIRTHDAY", 300, 95);
            const data = ctx.getImageData(0, 0, 600, 150).data;
            for(let y=0; y<150; y+=3) {
                for(let x=0; x<600; x+=3) {
                    if(data[(y*600+x)*4+3] > 128) textPoints.push(new THREE.Vector3((x-300)*0.13, (75-y)*0.13 + 5.5, 0));
                }
            }

            const mat = new THREE.MeshPhongMaterial({ 
                color: 0xffffff, shininess: 200, emissive: 0x111111, transparent: true, opacity: 0.95 
            });
            pMesh = new THREE.InstancedMesh(new THREE.SphereGeometry(0.12, 6, 6), mat, PARTICLE_COUNT);
            dummy = new THREE.Object3D();

            for(let i=0; i<PARTICLE_COUNT; i++) {
                let cPos, sPos, tPos, color, isFlame = false, fGrade = 0;

                if (i < PARTICLE_COUNT * 0.6) {
                    const r = 4 + Math.random()*2, a = Math.random()*Math.PI*2, h = (Math.random()-0.5)*4.5;
                    cPos = new THREE.Vector3(r*Math.cos(a), h, r*Math.sin(a));
                    color = new THREE.Color(0xFFD700).lerp(new THREE.Color(0xFFFFFF), Math.random()*0.3);
                } else if (i < PARTICLE_COUNT * 0.9) {
                    const r = Math.random()*3, a = Math.random()*Math.PI*2, h = Math.random()*3.5 + 2.5;
                    cPos = new THREE.Vector3(r*Math.cos(a), h, r*Math.sin(a));
                    color = new THREE.Color(0xFF1493).lerp(new THREE.Color(0xFFFFFF), Math.random()*0.4);
                } else {
                    fGrade = Math.random();
                    const h = fGrade * 2.8 + 6, r = (1.0 - fGrade) * 0.4;
                    const a = Math.random()*Math.PI*2;
                    cPos = new THREE.Vector3(r*Math.cos(a), h, r*Math.sin(a));
                    color = fGrade < 0.2 ? new THREE.Color(0xCCFFFF) : (fGrade < 0.7 ? new THREE.Color(0xFFD700) : new THREE.Color(0xFF4400));
                    isFlame = true;
                }

                sPos = new THREE.Vector3((Math.random()-0.5)*55, (Math.random()-0.5)*50, (Math.random()-0.5)*55);
                tPos = (i < textPoints.length * 3) ? textPoints[i % textPoints.length].clone().add(new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.5)) : sPos.clone();

                particles.push({ curr: cPos.clone(), cake: cPos, scatter: sPos, text: tPos, isFlame, fGrade, seed: Math.random()*50 });
                dummy.position.copy(cPos); dummy.updateMatrix();
                pMesh.setMatrixAt(i, dummy.matrix);
                pMesh.setColorAt(i, color);
            }
            scene.add(pMesh);

            for(let i=0; i<5; i++) {
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8, 5.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide }));
                mesh.userData = { home: new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*30, (Math.random()-0.5)*20) };
                mesh.position.copy(mesh.userData.home);
                scene.add(mesh); photoPlanes.push(mesh);
            }
        }

        function transformTo(ns) {
            if (isLock || state === ns) return;
            isLock = true; state = ns;
            const dur = ns === 'scattered' ? 900 : 1800;
            const wick = scene.getObjectByName("wick");

            if (ns === 'assembled') {
                isLit = true; new TWEEN.Tween(wick).to({intensity: 8}, 1000).start(); 
                controls.autoRotate = true;
                document.getElementById('gesture-hint').innerText = "WISH: POUT ðŸ˜— | EXPLODE: OPEN HAND âœ‹";
            } else {
                isLit = false; new TWEEN.Tween(wick).to({intensity: 0.1}, 400).start();
                controls.autoRotate = false;
                if(ns === 'text') new TWEEN.Tween(scene.rotation).to({y: 0}, 1000).start();
                document.getElementById('gesture-hint').innerText = ns === 'text' ? "HAPPY BIRTHDAY âœ¨" : "MEMORIES DISPERSED";
            }

            particles.forEach((p, i) => {
                const target = ns === 'assembled' ? p.cake : (ns === 'text' ? p.text : p.scatter);
                new TWEEN.Tween(p.curr).to({x: target.x, y: target.y, z: target.z}, dur + Math.random()*600)
                    .easing(ns === 'scattered' ? TWEEN.Easing.Back.Out : TWEEN.Easing.Exponential.InOut)
                    .start();
                if (p.isFlame) pMesh.setColorAt(i, ns === 'assembled' ? new THREE.Color(p.fGrade < 0.2 ? 0xCCFFFF : (p.fGrade < 0.7 ? 0xFFD700 : 0xFF4400)) : new THREE.Color(0x110500));
            });
            pMesh.instanceColor.needsUpdate = true;
            
            photoPlanes.forEach(m => {
                new TWEEN.Tween(m.material).to({opacity: (ns === 'scattered' && photos.length > 0) ? 0.95 : 0}, 1000).start();
            });

            setTimeout(() => { isLock = false; }, dur + 600);
        }

        async function setupAI() {
            const vis = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm");
            handAI = await HandLandmarker.createFromOptions(vis, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            faceAI = await FaceLandmarker.createFromOptions(vis, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`, delegate: "GPU" },
                outputFaceBlendshapes: true, runningMode: "VIDEO", numFaces: 1
            });
        }

        function predict() {
            const now = performance.now();
            if (now - lastAiTime > 150 && !isLock) {
                lastAiTime = now;
                let detectedHand = handAI.detectForVideo(video, now);
                let detectedFace = faceAI.detectForVideo(video, now);

                let next = state;
                if (detectedHand.landmarks.length > 0) {
                    const l = detectedHand.landmarks[0];
                    const d = Math.hypot(l[8].x-l[0].x, l[8].y-l[0].y);
                    if (d > 0.45 && state === 'assembled') next = 'scattered';
                    if (d < 0.2 && state !== 'assembled') next = 'assembled';
                }
                if (detectedFace.faceBlendshapes.length > 0) {
                    const s = detectedFace.faceBlendshapes[0].categories.find(c => c.categoryName === 'mouthPucker').score;
                    if (s > 0.6 && state === 'assembled') next = 'text';
                }

                // é²æ£’æ€§åˆ¤å®šï¼šè¿žç»­ä¸¤å¸§ç›¸åŒæ‰‹åŠ¿æ‰åˆ‡æ¢
                if (next !== state) {
                    if (targetState === next) {
                        gestureTimer++;
                        if (gestureTimer > 2) transformTo(next);
                    } else {
                        targetState = next;
                        gestureTimer = 0;
                    }
                }
            }
            requestAnimationFrame(predict);
        }

        function setupVideo() {
            video = document.getElementById('video-input');
            navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
                video.srcObject = s; video.onloadeddata = () => predict();
            });
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            document.getElementById('file-input').onchange = (e) => {
                const loader = new THREE.TextureLoader();
                for(let i=0; i<Math.min(e.target.files.length, 5); i++) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const tex = loader.load(ev.target.result);
                        tex.colorSpace = THREE.SRGBColorSpace;
                        photos[i] = tex; photoPlanes[i].material.map = tex; photoPlanes[i].material.needsUpdate = true;
                    };
                    reader.readAsDataURL(e.target.files[i]);
                }
            };
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update(); controls.update();
            const t = Date.now() * 0.0015;

            // GPU æ€§èƒ½ä¼˜åŒ–ï¼šåˆ†æ‰¹æ¬¡æ›´æ–° Instance
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const p = particles[i];
                if (p.isFlame && isLit && state === 'assembled') {
                    const drift = Math.sin(t * 8 + p.seed) * (p.fGrade * 0.25);
                    dummy.position.set(p.curr.x + drift, p.curr.y + Math.sin(t*12+p.seed)*0.06, p.curr.z + drift);
                } else if (state === 'text' && i < textPoints.length * 3) {
                    const vib = Math.sin(t * 5 + i) * 0.02;
                    dummy.position.set(p.curr.x + vib, p.curr.y + vib, p.curr.z + vib);
                } else {
                    dummy.position.copy(p.curr);
                }
                dummy.updateMatrix();
                pMesh.setMatrixAt(i, dummy.matrix);
            }
            pMesh.instanceMatrix.needsUpdate = true;
            if (isLit) scene.getObjectByName("wick").intensity = 8 + Math.sin(t*10);
            composer.render();
        }

        init();
    </script>
</body>
</html>
