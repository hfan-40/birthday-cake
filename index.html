<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luxury Birthday - Stability Version</title>
    <style>
        body { margin: 0; overflow: hidden; background: #080808; font-family: 'Times New Roman', serif; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; padding-top: 5vh; }
        
        h1 {
            color: #f0e6d2; font-size: 2.5rem; letter-spacing: 0.5rem; text-transform: uppercase;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.6); margin-bottom: 10px; opacity: 0; animation: fadeIn 2s forwards 1s;
        }

        .hint {
            color: #d4af37; font-size: 0.9rem; border: 1px solid rgba(212, 175, 55, 0.3);
            padding: 8px 20px; border-radius: 20px; background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px); opacity: 0; animation: fadeIn 2s forwards 2s; transition: all 0.5s;
        }

        #loader { position: fixed; inset: 0; background: #000; z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 1s ease; }
        .circle { width: 50px; height: 50px; border: 2px solid rgba(212, 175, 55, 0.2); border-top: 2px solid #d4af37; border-radius: 50%; animation: spin 1s infinite linear; }
        .status-text { color: #666; margin-top: 15px; font-size: 12px; font-family: sans-serif; }

        #webcam-preview { 
            position: absolute; bottom: 20px; right: 20px; width: 120px; height: 90px; 
            border: 1px solid #d4af37; border-radius: 8px; z-index: 20; 
            transform: scaleX(-1); opacity: 0; transition: opacity 0.5s;
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { to { opacity: 1; } }
    </style>
</head>
<body>

    <div id="loader">
        <div class="circle"></div>
        <div class="status-text" id="log">INITIALIZING SYSTEM...</div>
    </div>

    <div id="ui-layer">
        <h1 id="title">Grand Celebration</h1>
        <div class="hint" id="guide">ğŸ– å¼ å¼€: æ•£æ”¾ | âœŠ æ¡æ‹³: èšåˆ | ğŸ˜— å˜Ÿå˜´: å¹æ°”è®¸æ„¿</div>
    </div>

    <video id="webcam" autoplay playsinline style="display:none;"></video>
    <canvas id="webcam-preview"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';

        // --- ç³»ç»Ÿé…ç½® ---
        const CONFIG = {
            count: 4500,
            colors: { gold: 0xffd700, rose: 0xffb7c5, white: 0xffffff },
            blowThreshold: 0.5
        };

        // --- å…¨å±€çŠ¶æ€ ---
        let scene, camera, renderer, composer, particles;
        let handLandmarker, faceLandmarker, video;
        let puckerCounter = 0;
        let state = {
            mode: 'CAKE', // CAKE, SCATTER, TEXT
            isBlown: false,
            rotation: 0,
            useAI: false // æ ‡è®°æ˜¯å¦æˆåŠŸå¯ç”¨äº† AI
        };

        const particleData = {
            cake: new Float32Array(CONFIG.count * 3),
            text: new Float32Array(CONFIG.count * 3),
            current: new Float32Array(CONFIG.count * 3),
            noise: new Float32Array(CONFIG.count)
        };

        const logger = document.getElementById('log');

        async function init() {
            try {
                logger.innerText = "Building 3D World...";
                initThree();
                generateShapes();
                
                logger.innerText = "Connecting AI Vision...";
                await initAI(); // å°è¯•åŠ è½½ AI
                state.useAI = true;
                document.getElementById('webcam-preview').style.opacity = 0.6;
                
            } catch (err) {
                console.warn("AI Init Failed (Fallback Mode):", err);
                enableMouseMode(); // å¤±è´¥åˆ™å¯ç”¨é¼ æ ‡æ¨¡å¼
            } finally {
                // æ— è®ºæˆåŠŸå¤±è´¥ï¼Œå¼ºåˆ¶ç§»é™¤åŠ è½½å±‚
                setTimeout(() => {
                    const loader = document.getElementById('loader');
                    loader.style.opacity = 0;
                    setTimeout(() => loader.remove(), 800);
                }, 500);
                animate();
            }
        }

        function enableMouseMode() {
            state.useAI = false;
            const guide = document.getElementById('guide');
            guide.innerText = "ğŸ–±ï¸ é¼ æ ‡äº¤äº’æ¨¡å¼: ç‚¹å‡»å±å¹•å¹ç­èœ¡çƒ›";
            guide.style.borderColor = "#ff4444";
            
            // é¼ æ ‡æ§åˆ¶æ—‹è½¬
            window.addEventListener('mousemove', (e) => {
                state.rotation = (e.clientX / window.innerWidth - 0.5) * 4;
            });
            // ç‚¹å‡»è§¦å‘å¹ç­
            window.addEventListener('click', triggerBlow);
            // è§¦æ‘¸è§¦å‘
            window.addEventListener('touchstart', triggerBlow);
        }

        function triggerBlow() {
            if (!state.isBlown) {
                state.isBlown = true;
                state.mode = 'TEXT';
                updateTitle();
            }
        }

        function updateTitle() {
            const t = document.getElementById('title');
            t.style.opacity = 0;
            setTimeout(() => {
                t.innerText = "Make A Wish!";
                t.style.opacity = 1;
            }, 500);
        }

        // --- Three.js æ ¸å¿ƒ ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 40);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // è¾‰å…‰ç‰¹æ•ˆ
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);

            // ç²’å­åˆå§‹åŒ–
            const geo = new THREE.BufferGeometry();
            const colors = [];
            
            for(let i=0; i<CONFIG.count; i++) {
                particleData.current[i*3] = (Math.random()-0.5)*100;
                particleData.current[i*3+1] = (Math.random()-0.5)*100;
                particleData.current[i*3+2] = (Math.random()-0.5)*100;
                particleData.noise[i] = Math.random() * 100;

                const c = new THREE.Color(i%3===0 ? CONFIG.colors.rose : (i%3===1 ? CONFIG.colors.gold : CONFIG.colors.white));
                colors.push(c.r, c.g, c.b);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(particleData.current, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            particles = new THREE.Points(geo, new THREE.PointsMaterial({
                size: 0.18, vertexColors: true, transparent: true, 
                blending: THREE.AdditiveBlending, depthWrite: false
            }));
            scene.add(particles);
        }

        // --- å½¢çŠ¶ç”Ÿæˆ ---
        function generateShapes() {
            // è›‹ç³•å½¢çŠ¶
            for(let i=0; i<CONFIG.count; i++) {
                const angle = Math.random() * Math.PI * 2;
                let r, y;
                if(i < CONFIG.count * 0.6) { // åº•å±‚
                    r = 8 + Math.random(); y = Math.random()*6-4;
                } else { // é¡¶å±‚
                    r = 5 + Math.random(); y = Math.random()*5+2;
                    if(Math.random()>0.8) y -= Math.sin(angle*5)*1.5; // å¥¶æ²¹æµæ·Œ
                }
                particleData.cake[i*3] = Math.cos(angle)*r;
                particleData.cake[i*3+1] = y;
                particleData.cake[i*3+2] = Math.sin(angle)*r;
            }

            // æ–‡å­—å½¢çŠ¶
            const cvs = document.createElement('canvas');
            cvs.width=600; cvs.height=150;
            const ctx = cvs.getContext('2d');
            ctx.font='900 60px Times New Roman';
            ctx.fillStyle='white'; ctx.textAlign='center';
            ctx.fillText('HAPPY BIRTHDAY', 300, 80);
            const data = ctx.getImageData(0,0,600,150).data;
            const valid = [];
            for(let y=0; y<150; y+=3) for(let x=0; x<600; x+=3) 
                if(data[(y*600+x)*4]>128) valid.push({x:(x-300)*0.12, y:(75-y)*0.12+5});
            
            for(let i=0; i<CONFIG.count; i++) {
                const p = valid[i%valid.length];
                particleData.text[i*3] = p.x;
                particleData.text[i*3+1] = p.y;
                particleData.text[i*3+2] = (Math.random()-0.5)*2;
            }
        }

        // --- AI è§†è§‰ (å¸¦è¶…æ—¶ä¿æŠ¤) ---
        async function initAI() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error("WebCam API not available (Non-HTTPS?)");
            }

            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            
            // ä¸²è¡ŒåŠ è½½
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });

            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", outputFaceBlendshapes: true
            });

            video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            
            return new Promise(resolve => {
                video.onloadeddata = () => {
                    const preview = document.getElementById('webcam-preview');
                    preview.getContext('2d').drawImage(video, 0, 0);
                    resolve();
                };
            });
        }

        // --- æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            // AI é€»è¾‘
            if (state.useAI && video.readyState >= 2) {
                // ç»˜åˆ¶é¢„è§ˆ
                const pc = document.getElementById('webcam-preview');
                pc.getContext('2d').drawImage(video, 0, 0, pc.width, pc.height);

                const t = performance.now();
                const hand = handLandmarker.detectForVideo(video, t);
                const face = faceLandmarker.detectForVideo(video, t);

                // æ‰‹åŠ¿
                if(hand.landmarks.length > 0) {
                    const lm = hand.landmarks[0];
                    const spread = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    if (!state.isBlown) state.mode = spread > 0.45 ? 'SCATTER' : 'CAKE';
                    state.rotation = (lm[9].x - 0.5) * 4;
                }

                // å¹æ°”
                if(face.faceBlendshapes.length > 0 && !state.isBlown) {
                    const pucker = face.faceBlendshapes[0].categories.find(c => c.categoryName === 'mouthPucker').score;
                    if(pucker > 0.5) {
                        puckerCounter++;
                        if(puckerCounter > 10) triggerBlow(); // æŒç»­å˜Ÿå˜´è§¦å‘
                    } else {
                        puckerCounter = 0;
                    }
                }
            } else if (!state.useAI) {
                // è‡ªåŠ¨æ—‹è½¬ (æ— AIæ¨¡å¼)
                state.rotation += 0.005;
            }

            // ç²’å­ç‰©ç†
            const pos = particles.geometry.attributes.position.array;
            let target;
            if(state.mode === 'TEXT') target = particleData.text;
            else if(state.mode === 'CAKE') target = particleData.cake;

            for(let i=0; i<CONFIG.count; i++) {
                const i3 = i*3;
                if(state.mode === 'SCATTER') {
                    pos[i3] += Math.sin(time + particleData.noise[i])*0.05;
                    pos[i3+1] += Math.cos(time + particleData.noise[i])*0.05;
                    pos[i3+2] += Math.sin(time*0.5 + particleData.noise[i])*0.05;
                } else {
                    const lerp = state.isBlown ? 0.05 : 0.1;
                    pos[i3] += (target[i3] - pos[i3]) * lerp;
                    pos[i3+1] += (target[i3+1] - pos[i3+1]) * lerp;
                    pos[i3+2] += (target[i3+2] - pos[i3+2]) * lerp;
                    
                    // æ‚¬æµ®å¾®åŠ¨
                    if(state.mode === 'TEXT') {
                        pos[i3] += Math.sin(time*3 + particleData.noise[i])*0.005;
                    }
                }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, state.rotation, 0.1);
            
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
