<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>粒子蛋糕与手势点火 - Cyberpunk Birthday</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 2px solid #333; opacity: 0.5; border-radius: 8px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ffcc; font-size: 24px; z-index: 10; pointer-events: none; transition: opacity 0.5s; text-align: center; }
        #ui-layer { position: absolute; bottom: 30px; width: 100%; text-align: center; color: white; z-index: 5; pointer-events: none; }
        .hud-text { background: rgba(0, 0, 0, 0.5); padding: 10px 20px; border: 1px solid #444; border-radius: 4px; display: inline-block; }
        .status-lit { color: #ffaa00; text-shadow: 0 0 10px #ff0000; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">正在初始化量子蛋糕...<br><span style="font-size:14px; color:#888;">请允许摄像头权限以进行点火仪式</span></div>
    <video id="video-input"></video>
    <div id="canvas-container"></div>
    
    <div id="ui-layer">
        <div class="hud-text" id="instruction">移动食指靠近烛芯以点燃火焰</div>
    </div>

<script>
/**
 * PART 1: THREE.JS 场景构建
 * 核心理念：万物皆粒子。
 */

// 场景设置
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050505, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);
camera.lookAt(0, 1, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.getElementById('canvas-container').appendChild(renderer.domElement);

// 辅助光源
const ambientLight = new THREE.AmbientLight(0x404040);
scene.add(ambientLight);
const pointLight = new THREE.PointLight(0xffffff, 1, 100);
pointLight.position.set(5, 5, 5);
scene.add(pointLight);

// --- 纹理生成器 (避免加载外部图片跨域问题) ---
function createTexture(type) {
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    
    if (type === 'soft') { // 柔和的光点 (火焰/蝴蝶结)
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);
    } else if (type === 'square') { // 方形 (照片云)
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(2, 2, 28, 28);
        ctx.fillStyle = '#aaaaaa'; // 模拟照片内容
        ctx.fillRect(4, 4, 24, 20);
    }
    
    const texture = new THREE.CanvasTexture(canvas);
    return texture;
}

const texSoft = createTexture('soft');
const texSquare = createTexture('square');

// --- 1. 蛋糕体：照片云 (Photo Cloud) ---
// 使用 Points 模拟大量照片汇聚成的实体
function createCakeLayer(radius, height, yPos, count, color) {
    const geometry = new THREE.CylinderGeometry(radius, radius, height, 60, 10);
    const vertices = [];
    const colors = [];
    
    // 采样几何体表面和内部
    for (let i = 0; i < count; i++) {
        // 简单的圆柱体随机采样
        const r = radius * Math.sqrt(Math.random());
        const theta = Math.random() * 2 * Math.PI;
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        const y = (Math.random() - 0.5) * height;
        
        vertices.push(x, y, z);
        
        // 随机微调颜色，模拟不同的照片
        const c = new THREE.Color(color);
        c.offsetHSL(0, 0, (Math.random() - 0.5) * 0.2);
        colors.push(c.r, c.g, c.b);
    }

    const bufGeo = new THREE.BufferGeometry();
    bufGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    bufGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.15,
        map: texSquare,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true
    });

    const points = new THREE.Points(bufGeo, material);
    points.position.y = yPos;
    return points;
}

const cakeBottom = createCakeLayer(3, 2, 1, 3000, 0xeeeeee); // 白色奶油层
const cakeTop = createCakeLayer(2, 1.5, 2.75, 2000, 0xffeebb); // 顶层
scene.add(cakeBottom);
scene.add(cakeTop);

// --- 2. 蝴蝶结：有序粒子 (Ordered State) ---
// 紧密的、几乎静止的粒子
const bowGeoRaw = new THREE.TorusKnotGeometry(0.8, 0.25, 120, 20);
const bowMat = new THREE.PointsMaterial({
    color: 0xff69b4, // Hot Pink
    size: 0.08,
    map: texSoft,
    blending: THREE.NormalBlending, // 实体感
    transparent: true,
    opacity: 0.8
});
const bowPoints = new THREE.Points(bowGeoRaw, bowMat);
bowPoints.position.set(0, 2.5, 2.1); // 放在蛋糕侧面
bowPoints.rotation.x = Math.PI / 6;
scene.add(bowPoints);

// --- 3. 蜡烛与火焰：无序能量 (Disordered State) ---

// 蜡烛实体
const candleGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 16);
const candleMat = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
const candle = new THREE.Mesh(candleGeo, candleMat);
candle.position.set(0, 4.25, 0); // 在顶层蛋糕之上
scene.add(candle);

// 烛芯位置 (触发点火的目标点)
const wickPosition = new THREE.Vector3(0, 5.1, 0);

// 火焰粒子系统
const flameParticleCount = 800;
const flameGeo = new THREE.BufferGeometry();
const fPositions = new Float32Array(flameParticleCount * 3);
const fColors = new Float32Array(flameParticleCount * 3);
const fSizes = new Float32Array(flameParticleCount);
const fLife = new Float32Array(flameParticleCount); // 生命周期

for(let i=0; i<flameParticleCount; i++) {
    fPositions[i*3] = 0; fPositions[i*3+1] = 0; fPositions[i*3+2] = 0;
    fLife[i] = Math.random(); 
    fSizes[i] = 0; // 初始大小为0 (熄灭)
}

flameGeo.setAttribute('position', new THREE.BufferAttribute(fPositions, 3));
flameGeo.setAttribute('color', new THREE.BufferAttribute(fColors, 3));
flameGeo.setAttribute('size', new THREE.BufferAttribute(fSizes, 1));

const flameMat = new THREE.PointsMaterial({
    size: 1.0,
    vertexColors: true,
    map: texSoft,
    blending: THREE.AdditiveBlending, // 发光感
    depthWrite: false,
    transparent: true,
    opacity: 0.8
});

const flameSystem = new THREE.Points(flameGeo, flameMat);
flameSystem.position.copy(wickPosition);
scene.add(flameSystem);

// 交互反馈：手指光标
const cursorGeo = new THREE.SphereGeometry(0.2, 16, 16);
const cursorMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, wireframe: true });
const cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
scene.add(cursorMesh);

// 状态变量
let isCandleLit = false;
let handDetected = false;

// 动画逻辑
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const time = clock.getElapsedTime();

    // 1. 旋转蛋糕展示
    cakeBottom.rotation.y = time * 0.1;
    cakeTop.rotation.y = time * 0.1;
    bowPoints.position.x = Math.sin(time * 0.1 + Math.PI/2) * 2.1; // 简单的跟随旋转逻辑简化
    bowPoints.position.z = Math.cos(time * 0.1 + Math.PI/2) * 2.1;
    bowPoints.rotation.y = time * 0.1;

    // 2. 蝴蝶结：微观振动 (有序)
    // 视觉上稍微闪烁即可，不需要重算位置以节省性能

    // 3. 火焰：流体动力学模拟 (无序)
    const positions = flameSystem.geometry.attributes.position.array;
    const colors = flameSystem.geometry.attributes.color.array;
    const sizes = flameSystem.geometry.attributes.size.array;

    for(let i=0; i<flameParticleCount; i++) {
        if (isCandleLit) {
            // 生命流逝
            fLife[i] -= dt * (0.8 + Math.random() * 0.5);

            // 如果死亡，重置到底部
            if (fLife[i] <= 0) {
                fLife[i] = 1;
                positions[i*3] = (Math.random() - 0.5) * 0.1; // X source
                positions[i*3+1] = 0; // Y source
                positions[i*3+2] = (Math.random() - 0.5) * 0.1; // Z source
            }

            // 向上运动 + 湍流
            positions[i*3+1] += dt * 2.5; // Up
            positions[i*3] += Math.sin(time * 5 + positions[i*3+1]) * dt * 0.5; // X wobble
            
            // 颜色：黄 -> 红 -> 黑
            const lifeRatio = fLife[i];
            sizes[i] = lifeRatio * 1.5; // 越往上越小
            
            if (lifeRatio > 0.8) { // 底部：白/黄
                colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 0.5;
            } else if (lifeRatio > 0.4) { // 中部：橙/红
                colors[i*3] = 1; colors[i*3+1] = lifeRatio; colors[i*3+2] = 0;
            } else { // 顶部：烟灰
                colors[i*3] = 0.2; colors[i*3+1] = 0.2; colors[i*3+2] = 0.2;
            }
        } else {
            // 熄灭状态：粒子不可见
            sizes[i] = 0;
        }
    }
    flameSystem.geometry.attributes.position.needsUpdate = true;
    flameSystem.geometry.attributes.color.needsUpdate = true;
    flameSystem.geometry.attributes.size.needsUpdate = true;

    // 渲染
    renderer.render(scene, camera);
}

animate();

/**
 * PART 2: MediaPipe Hands 集成
 */
const videoElement = document.getElementById('video-input');
const loadingText = document.getElementById('loading');
const instructionText = document.getElementById('instruction');

function onResults(results) {
    loadingText.style.opacity = 0; // 隐藏加载文字

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handDetected = true;
        const landmarks = results.multiHandLandmarks[0];
        
        // 获取食指指尖 (Index Finger Tip, 索引 8)
        const indexTip = landmarks[8];

        // 坐标映射：MediaPipe (0~1) -> Three.js World (Approx)
        // 注意：Webcam是镜像的，x轴需要反转
        const vector = new THREE.Vector3(
            -(indexTip.x - 0.5) * 8, // 映射 X
            -(indexTip.y - 0.5) * 6 + 2, // 映射 Y (向上偏移以匹配蛋糕高度)
            (indexTip.z) * -5 // 深度映射 (粗略估计)
        );

        // 更新光标位置
        cursorMesh.position.lerp(vector, 0.2); // 平滑插值

        // 检测是否触碰烛芯
        const distance = cursorMesh.position.distanceTo(wickPosition);
        
        // 判定逻辑：距离小于阈值
        if (distance < 0.8 && !isCandleLit) {
            triggerIgnition();
        }

    } else {
        handDetected = false;
    }
}

function triggerIgnition() {
    isCandleLit = true;
    instructionText.innerHTML = "<span class='status-lit'>★ 生日快乐！火焰已点燃 ★</span>";
    instructionText.style.borderColor = "#ffaa00";
    
    // 爆发效果：点燃瞬间改变背景色一瞬间
    const originalBg = scene.fog.color.getHex();
    scene.fog.color.setHex(0x331100);
    setTimeout(() => {
        scene.fog.color.setHex(originalBg);
    }, 200);
}

const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults(onResults);

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 640,
    height: 480
});

cameraUtils.start();

// 窗口调整
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
