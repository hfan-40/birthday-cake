<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rose Gold Ultimate Cinematic Cake</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Times New Roman', serif; }
        #loader { 
            position: fixed; inset: 0; background: #000; z-index: 100; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            color: #FFD1DC; letter-spacing: 5px; transition: opacity 1s; 
        }
        .spinner { width: 50px; height: 50px; border: 3px solid rgba(255,143,163,0.2); border-top-color: #D4AF37; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; color: #D4AF37; pointer-events: none; text-shadow: 0 0 10px rgba(0,0,0,0.8); font-weight: bold; letter-spacing: 2px; }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="load-text">LUXURY RENDERING...</div>
    </div>
    <div id="ui">✨ 双手张开：魔法爆发 | 嘟嘴：吹灭蜡烛 ✨</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';

        // --- 核心配置 ---
        const CONFIG = {
            count: 300,
            colors: {
                rose: 0xE5B3A6,  // 优化后的精致玫瑰粉
                gold: 0xD4AF37,  // 经典金属金
                ivory: 0xFFFFF0, // 象牙白
                flame: 0xFF4500
            },
            lerpSpeed: 0.1,      // AI 平滑系数
            magicStrength: 0.15  // 过渡抖动强度
        };

        let scene, camera, renderer, composer, mainGroup, bloomPass;
        let handLandmarker, faceLandmarker, video;
        let particles = [], flameObj = null;
        let state = { rotation: 0, isBlown: false, step: 0 }; // 0: 蛋糕, 1: 爆发

        async function init() {
            // 场景与相机
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 50);

            // 渲染器增强
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            // 1. 视觉抛光：环境映射 (EnvMap)
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            // 2. 电影感后期：辉光与光晕
            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.3, 0.8);
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            createUltimateCake();
            await setupAI();
            
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 1000);
            animate();
        }

        function createUltimateCake() {
            // 几何体定义 (问题一：移除爱心，改为立方体组合)
            const geos = [
                new THREE.SphereGeometry(0.7, 24, 24),
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.CylinderGeometry(0.3, 0.3, 2, 12), // 糖果
                new THREE.ConeGeometry(0.7, 1.2, 4)           // 三棱锥
            ];

            const mats = {
                rose: new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.rose, metalness: 0.2, roughness: 0.2, clearcoat: 1.0 }),
                gold: new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.1, envMapIntensity: 2.5 }),
                ivory: new THREE.MeshStandardMaterial({ color: CONFIG.colors.ivory, roughness: 0.8 })
            };

            for (let i = 0; i < CONFIG.count; i++) {
                const isTop = i > CONFIG.count * 0.5;
                const isBow = i < 40; 
                
                const g = geos[Math.floor(Math.random() * geos.length)];
                let m = isTop ? mats.rose : mats.ivory;
                if (Math.random() > 0.8 || isBow) m = mats.gold;

                const mesh = new THREE.Mesh(g, m);
                
                // 布局算法：增大缝隙与体量
                let targetPos = new THREE.Vector3();
                if (isBow) {
                    const side = i % 2 === 0 ? 1 : -1;
                    targetPos.set(side * 10, -3 + Math.random(), 9.5);
                } else {
                    const radius = isTop ? 7 + Math.random() * 2 : 10 + Math.random() * 2;
                    const angle = Math.random() * Math.PI * 2;
                    targetPos.set(Math.cos(angle) * radius, isTop ? 5 + Math.random() * 5 : -5 + Math.random() * 10, Math.sin(angle) * radius);
                }

                mesh.position.copy(targetPos);
                mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);
                mainGroup.add(mesh);

                particles.push({ 
                    mesh, 
                    target: targetPos.clone(), 
                    origin: targetPos.clone(), 
                    noiseSeed: Math.random() * 100 
                });
            }

            // 蜡烛与火焰
            const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 6, 16), mats.ivory);
            candle.position.set(0, 12, 0);
            mainGroup.add(candle);

            const flameGeo = new THREE.LatheGeometry([
                new THREE.Vector2(0, 0), new THREE.Vector2(0.5, 0.3), new THREE.Vector2(0.3, 1.2), new THREE.Vector2(0, 1.5)
            ], 16);
            const flameMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xff4400, emissiveIntensity: 4 });
            flameObj = new THREE.Mesh(flameGeo, flameMat);
            flameObj.position.set(0, 3.5, 0);
            candle.add(flameObj);
        }

        async function setupAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", outputFaceBlendshapes: true
            });
            video = document.createElement('video');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.play();
            return new Promise(res => video.onloadeddata = res);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            if (video.readyState >= 2) {
                const hResults = handLandmarker.detectForVideo(video, performance.now());
                const fResults = faceLandmarker.detectForVideo(video, performance.now());

                // 1. 体验：平滑 AI 过渡 (Lerp)
                if (hResults.landmarks.length > 0) {
                    const targetRot = (hResults.landmarks[0][9].x - 0.5) * 4;
                    state.rotation = THREE.MathUtils.lerp(state.rotation, targetRot, CONFIG.lerpSpeed);
                    
                    // 烟花爆发逻辑
                    if (hResults.landmarks.length === 2) {
                        const d = Math.hypot(hResults.landmarks[0][9].x - hResults.landmarks[1][9].x);
                        if (d > 0.6) {
                            state.step = 1;
                            bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 3.0, 0.2);
                        } else {
                            state.step = 0;
                            bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 0.8, 0.1);
                        }
                    }
                }

                if (fResults.faceBlendshapes.length > 0) {
                    const pucker = fResults.faceBlendshapes[0].categories.find(c => c.categoryName === 'mouthPucker').score;
                    if (pucker > 0.45) state.isBlown = true;
                }
            }

            mainGroup.rotation.y = state.rotation;

            // 2. 逻辑：粒子魔法过渡 (问题三：火焰始终向上)
            if (flameObj) {
                flameObj.rotation.y = -mainGroup.rotation.y; // 抵消父级旋转
                flameObj.scale.setScalar(1 + Math.sin(time * 12) * 0.1);
                if (state.isBlown) flameObj.visible = false;
            }

            particles.forEach((p, i) => {
                // 3. 魔法偏移 (Noise offset during transition)
                const magicOffset = state.step === 1 ? Math.sin(time * 2 + p.noiseSeed) * 15 : 0;
                const targetY = state.step === 1 ? p.origin.y + 20 : p.origin.y;
                
                p.mesh.position.x += (p.origin.x - p.mesh.position.x) * 0.05 + Math.cos(time + i) * magicOffset * 0.01;
                p.mesh.position.y += (targetY - p.mesh.position.y) * 0.05;
                p.mesh.position.z += (p.origin.z - p.mesh.position.z) * 0.05;
                
                p.mesh.rotation.x += 0.01;
                p.mesh.rotation.z += 0.01;
            });

            composer.render();
        }

        init();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
