<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Luxury Birthday Cake - Interactive Blowing</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Cinzel', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; align-items: center; padding-top: 40px; }
        h1 { color: #fceea7; font-size: 32px; letter-spacing: 6px; text-shadow: 0 0 30px rgba(252, 238, 167, 0.4); background: linear-gradient(to bottom, #fff, #e1b382); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin: 0; }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .spinner { width: 40px; height: 40px; border: 2px solid rgba(212, 175, 55, 0.1); border-top-color: #d4af37; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        #webcam-preview { position: absolute; bottom: 20px; right: 20px; width: 130px; height: 98px; border: 1px solid rgba(212, 175, 55, 0.5); border-radius: 12px; z-index: 20; background: #000; transform: scaleX(-1); }
        .hint { color: #d4af37; font-size: 11px; margin-top: 15px; letter-spacing: 2px; text-transform: uppercase; }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="hint" id="status">æ­£åœ¨åŠ è½½é¢éƒ¨è¯†åˆ«å¼•æ“...</div>
    </div>

    <div id="ui-layer">
        <h1 id="title">Grand Celebration</h1>
        <div class="hint">ğŸ– å¼ å¼€ï¼šç»½æ”¾ | âœŠ æ¡æ‹³ï¼šèšåˆ | ğŸ˜— å˜Ÿå˜´å¹æ°”ï¼šç‚¹äº®æƒŠå–œ</div>
    </div>

    <canvas id="webcam-preview"></canvas>
    <div id="canvas-container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';

        let scene, camera, renderer, composer, mainGroup;
        let handLandmarker, faceLandmarker, video, lastVideoTime = -1;
        let cakeElements = [], textPoints = [];
        let state = { mode: 'CAKE', isBlown: false, rotY: 0 };

        const COLORS = { rose: 0xffb7c5, gold: 0xd4af37, ivory: 0xfffff0 };

        async function init() {
            setupScene();
            createTextPoints(); // é¢„ç”Ÿæˆæ–‡å­—åæ ‡
            createInteractiveCake();
            setupPostProcessing();
            
            try {
                await initAI();
            } catch (e) { console.warn("AI Init failed."); }

            document.getElementById('loader').style.display = 'none';
            animate();
        }

        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(38, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.8;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const spot = new THREE.SpotLight(0xffffff, 150);
            spot.position.set(10, 30, 20);
            scene.add(spot);
        }

        // ç”Ÿæˆ "HAPPY BIRTHDAY" å½¢çŠ¶çš„åæ ‡ç‚¹é˜µ
        function createTextPoints() {
            const canvas = document.createElement('canvas');
            canvas.width = 400; canvas.height = 100;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 50px Arial';
            ctx.fillText('HAPPY BDAY', 10, 70);
            
            const imageData = ctx.getImageData(0, 0, 400, 100).data;
            for (let y = 0; y < 100; y += 4) {
                for (let x = 0; x < 400; x += 4) {
                    if (imageData[(y * 400 + x) * 4] > 128) {
                        textPoints.push(new THREE.Vector3((x - 200) * 0.15, (50 - y) * 0.15 + 10, 0));
                    }
                }
            }
        }

        function createInteractiveCake() {
            const goldMat = new THREE.MeshPhysicalMaterial({ color: COLORS.gold, metalness: 1, roughness: 0.1 });
            const geo = new THREE.SphereGeometry(0.3, 8, 8);

            // ç”¨ç²’å­å¡«å……è›‹ç³•å½¢çŠ¶
            for (let i = 0; i < 2000; i++) {
                const mesh = new THREE.Mesh(geo, goldMat);
                const angle = Math.random() * Math.PI * 2;
                let home = new THREE.Vector3();
                
                // åˆ†é…åˆ°è›‹ç³•çš„åŒå±‚ç»“æ„
                if (i < 1200) {
                    const r = 8 + Math.random() * 1.5;
                    home.set(Math.cos(angle)*r, Math.random()*6-3, Math.sin(angle)*r);
                } else {
                    const r = 5 + Math.random() * 1.2;
                    home.set(Math.cos(angle)*r, Math.random()*5+3, Math.sin(angle)*r);
                }

                mesh.position.set(Math.random()*60-30, Math.random()*60-30, Math.random()*60-30);
                mainGroup.add(mesh);
                
                // èµ‹äºˆæ–‡å­—ç›®æ ‡ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰å¯¹åº”çš„æ–‡å­—ç‚¹ï¼Œåˆ™éšæœºæ•£å¼€
                const textTarget = textPoints[i % textPoints.length] || new THREE.Vector3(Math.random()*40-20, 20, Math.random()*40-20);

                cakeElements.push({
                    mesh,
                    home,
                    scatter: mesh.position.clone().multiplyScalar(2),
                    textTarget
                });
            }
        }

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            
            // åŒæ—¶åˆå§‹åŒ–æ‰‹åŠ¿å’Œé¢éƒ¨è¯†åˆ«
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });

            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", outputFaceBlendshapes: true
            });

            video = document.getElementById('webcam-preview');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream; video.play();
        }

        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.8));
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();

            if (video && video.readyState >= 2 && video.currentTime !== lastVideoTime) {
                // æ‰‹åŠ¿å¤„ç†
                const handRes = handLandmarker.detectForVideo(video, now);
                if (handRes.landmarks.length > 0) {
                    const lm = handRes.landmarks[0];
                    const spread = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    if (!state.isBlown) state.mode = (spread > 0.4) ? 'SCATTER' : 'CAKE';
                    state.rotY = THREE.MathUtils.lerp(state.rotY, (lm[9].x - 0.5) * 4, 0.1);
                }

                // å˜Ÿå˜´ï¼ˆå¹æ°”ï¼‰å¤„ç†
                const faceRes = faceLandmarker.detectForVideo(video, now);
                if (faceRes.faceBlendshapes && faceRes.faceBlendshapes.length > 0) {
                    const shapes = faceRes.faceBlendshapes[0].categories;
                    // 'pucker' ç±»åˆ«ä»£è¡¨å˜Ÿå˜´ç¨‹åº¦
                    const pucker = shapes.find(c => c.categoryName === 'mouthPucker')?.score || 0;
                    if (pucker > 0.5 && !state.isBlown) {
                        state.isBlown = true;
                        state.mode = 'TEXT';
                        document.getElementById('title').innerText = "Make A Wish!";
                    }
                }
                lastVideoTime = video.currentTime;
            }

            mainGroup.rotation.y = state.rotY;

            cakeElements.forEach(el => {
                let target;
                if (state.mode === 'TEXT') target = el.textTarget;
                else if (state.mode === 'SCATTER') target = el.scatter;
                else target = el.home;

                el.mesh.position.lerp(target, 0.08);
                if (state.mode === 'TEXT') el.mesh.rotation.y += 0.05;
            });

            composer.render();
        }

        init();
    </script>
</body>
</html>
