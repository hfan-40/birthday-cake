<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Lucky 777 Princess</title>
    <link rel="icon" href="data:;base64,=">
    <style>
        body { 
            margin: 0; overflow: hidden; background: #050203;
            font-family: 'Times New Roman', serif; 
            user-select: none; -webkit-user-select: none; 
        }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; padding-top: 6vh; }
        
        h1 {
            color: #FFD1DC; font-size: 3.2rem; letter-spacing: 0.3rem; text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255, 182, 193, 0.6), 0 0 40px rgba(255, 228, 225, 0.4);
            margin-bottom: 15px; opacity: 0; animation: fadeIn 2s forwards 0.5s; text-align: center;
        }

        .hint-container {
            display: flex; align-items: center; gap: 10px;
            background: rgba(60, 20, 30, 0.6); border: 1px solid rgba(255, 192, 203, 0.4);
            padding: 12px 35px; border-radius: 50px; 
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            opacity: 0; animation: fadeIn 2s forwards 1.5s;
            box-shadow: 0 0 30px rgba(255, 182, 193, 0.2); transition: all 0.5s;
        }
        .hint-text { color: #FFB6C1; font-size: 1rem; letter-spacing: 2px; font-weight: 700; text-shadow: 0 0 5px rgba(0,0,0,0.8); }
        .status-dot { width: 10px; height: 10px; background: #ff6666; border-radius: 50%; transition: all 0.5s; border: 2px solid #fff; box-shadow: 0 0 10px #ff3333; }
        .status-active { background: #66ff66; box-shadow: 0 0 15px #33ff33; border-color: #ccffcc; }

        #loader { position: fixed; inset: 0; background: #050102; z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 1s ease; pointer-events: auto; }
        .circle { width: 100px; height: 100px; border: 3px solid rgba(255, 182, 193, 0.3); border-top: 3px solid #FF69B4; border-radius: 50%; animation: spin 1s infinite linear; }
        .log-text { color: #FFC0CB; margin-top: 30px; font-size: 14px; letter-spacing: 4px; font-family: monospace; text-transform: uppercase; }

        #webcam-preview { 
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
            border: 2px solid rgba(255, 192, 203, 0.5); border-radius: 12px; z-index: 20; 
            transform: scaleX(-1); opacity: 0; transition: opacity 0.5s;
            box-shadow: 0 5px 20px rgba(50, 10, 20, 0.5);
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { to { opacity: 1; } }
    </style>
</head>
<body>

    <div id="loader">
        <div class="circle"></div>
        <div class="log-text" id="log">Setting 777 Gems...</div>
    </div>

    <div id="ui-layer">
        <h1 id="title">Princess Celebration</h1>
        <div class="hint-container" id="hint-box">
            <span id="ai-status" class="status-dot"></span>
            <span class="hint-text" id="guide">Ê≠£Âú®ÂêØÂä® AI ËßÜËßâ...</span>
        </div>
    </div>

    <video id="webcam" autoplay playsinline style="display:none;"></video>
    <canvas id="webcam-preview"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';

        // --- ÊúÄÁªà‰øÆÊ≠£ÈÖçÁΩÆ ---
        const CONFIG = {
            count: 777, // ‰∏•Ê†ºÈîÅÂÆö 777
            colors: {
                pearl: new THREE.Color(0xFFFFFA), // ÁèçÁè†ÁôΩ
                pink: new THREE.Color(0xFFC1CC),  // Ê≥°Ê≥°Á≤â
                gold: new THREE.Color(0xFFD700),  // ÈáëËâ≤
                flame: new THREE.Color(0xFF5500), // ÁÅ´ÁÑ∞
                smoke: new THREE.Color(0x333333)  
            },
            blowThreshold: 0.25, // ÁÅµÊïèÂ∫¶È´ò
            spreadThreshold: 0.4, 
        };

        let scene, camera, renderer, composer, mainGroup;
        let handLandmarker, faceLandmarker, video;
        let puckerFrames = 0;
        let state = { step: 0, rotation: 0, aiReady: false, blowStartTime: 0 }; 

        const particleData = {
            cakePos: new Float32Array(CONFIG.count * 3),
            textPos: new Float32Array(CONFIG.count * 3),
            scatterPos: new Float32Array(CONFIG.count * 3), 
            currentPos: new Float32Array(CONFIG.count * 3),
            currentRot: new Float32Array(CONFIG.count * 3),
            type: new Uint8Array(CONFIG.count), // 0:ËõãÁ≥ï, 1:ÁÉõÂè∞, 2:ÁÅ´ÁÑ∞
            shapeType: new Uint8Array(CONFIG.count), 
            noise: new Float32Array(CONFIG.count),
            meshMapping: Array.from({length: CONFIG.count}, () => ({meshIdx: 0, instanceIdx: 0}))
        };

        const shapes = { meshes: [], dummy: new THREE.Object3D() };
        const logger = document.getElementById('log');
        const guide = document.getElementById('guide');

        async function init() {
            try {
                logger.innerText = "Creating 3D Scene...";
                initThree(); 
                generateShapes(); 
                
                logger.innerText = "Initializing AI...";
                await initAI();
                
                state.aiReady = true;
                document.getElementById('ai-status').classList.add('status-active');
                document.getElementById('webcam-preview').style.opacity = 1;
                guide.innerText = "‚ú® ÂòüÂò¥ÂêπÁÅ≠ Êàñ Âº†ÊâãÁÇ∏Ë£Ç ‚ú®"; 
                
            } catch (err) {
                console.warn("AI Init Failed:", err);
                state.aiReady = false;
                guide.innerText = "üñ±Ô∏è ÁÇπÂáªÂ±èÂπïÂêπÁÅ≠Ëú°ÁÉõ";
                setupMouseFallback();
            } finally {
                setTimeout(() => {
                    const loader = document.getElementById('loader');
                    if(loader) loader.remove();
                }, 1500);
                animate();
            }
        }

        function setupMouseFallback() {
            window.addEventListener('click', triggerBlowSequence);
            window.addEventListener('mousemove', e => {
                if (state.step !== 2) {
                    state.rotation = (e.clientX / window.innerWidth - 0.5) * 4;
                }
            });
        }

        function triggerBlowSequence() {
            if (state.step === 0) {
                state.step = 1;
                state.blowStartTime = performance.now();
                setTimeout(() => {
                    state.step = 2; 
                    updateTitle("Happy Birthday!", 1);
                    guide.innerText = state.aiReady ? "üëê Âº†ÂºÄÊâãÊéåÔºöÈáäÊîæÈ≠îÊ≥ïÁÇ∏Ë£Ç" : "üñ±Ô∏è ÁßªÂä®Èº†Ê†áËßÇËµè";
                }, 1600);
            }
        }

        function resetToCake() {
            if (state.step !== 0) {
                state.step = 0;
                updateTitle("Princess Celebration", 0); 
                guide.innerText = state.aiReady ? "‚ú® ÂòüÂò¥ÂêπÁÅ≠ Êàñ Âº†ÊâãÁÇ∏Ë£Ç ‚ú®" : "üñ±Ô∏è ÁÇπÂáªÂ±èÂπïÂêπÁÅ≠Ëú°ÁÉõ";
                setFlameColor(CONFIG.colors.flame);
            }
        }

        function setFlameColor(color) {
            for(let i=0; i<CONFIG.count; i++) {
                const map = particleData.meshMapping[i];
                if (map && particleData.type[i] === 2 && shapes.meshes[map.meshIdx]) {
                     shapes.meshes[map.meshIdx].setColorAt(map.instanceIdx, color);
                }
            }
            shapes.meshes.forEach(m => { if(m.instanceColor) m.instanceColor.needsUpdate = true; });
        }

        function updateTitle(text, opacity) {
            const t = document.getElementById('title');
            t.style.opacity = 0;
            setTimeout(() => {
                t.innerText = text;
                t.style.textShadow = opacity ? "0 0 30px #FFB6C1, 0 0 50px #FF69B4" : "none";
                t.style.opacity = opacity;
            }, 500);
        }

        // --- Âá†‰Ωï‰Ωì ---
        function createFlameGeometry() {
            const points = [];
            for ( let i = 0; i < 10; i ++ ) {
                const t = i / 9;
                points.push( new THREE.Vector2( Math.sin( t * Math.PI ) * 0.35 * (1-t), t * 1.6 ) );
            }
            const geo = new THREE.LatheGeometry( points, 12 );
            geo.center(); 
            geo.translate(0, 0.8, 0); 
            return geo;
        }

        function createBowGeometry() {
            // Â§ßËù¥Ëù∂Áªì
            const geo = new THREE.TorusKnotGeometry(0.6, 0.25, 64, 8, 2, 3);
            geo.scale(1, 0.6, 0.4); 
            return geo;
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050203, 0.015);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.physicallyCorrectLights = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; 
            document.body.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            const ambient = new THREE.AmbientLight(0xffcce0, 0.6); 
            scene.add(ambient);
            
            const dirLight = new THREE.DirectionalLight(0xfffff0, 1.8); 
            dirLight.position.set(15, 25, 15);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);
            
            const pointLightRose = new THREE.PointLight(0xff69b4, 2.0, 80); 
            pointLightRose.position.set(-20, 10, -10);
            scene.add(pointLightRose);

            const centerLight = new THREE.PointLight(0xffaa55, 1.0, 30);
            centerLight.position.set(0, 8, 0);
            mainGroup.add(centerLight);

            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.5, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);

            // --- ÊùêË¥® (ÊûÅÈ´òÁè†ÂÖâÊÑü) ---
            const matPearl = new THREE.MeshStandardMaterial({ color: CONFIG.colors.pearl, roughness: 0.05, metalness: 0.5, emissive: 0x111111 });
            const matPink = new THREE.MeshStandardMaterial({ color: CONFIG.colors.pink, roughness: 0.1, metalness: 0.4 });
            const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.05, metalness: 0.95 });
            const matFlame = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.flame, emissive: CONFIG.colors.flame, emissiveIntensity: 3.5, roughness: 0.0, metalness: 0.0 
            });
            
            // --- Âá†‰Ωï‰Ωì (ÊîæÂ§ßÂ∞∫ÂØ∏‰ª•ÈÄÇÈÖç777Êï∞Èáè) ---
            const sphereGeo = new THREE.SphereGeometry(0.5, 20, 20); 
            const boxGeo = new THREE.BoxGeometry(0.65, 0.65, 0.65); 
            const candyGeo = new THREE.CylinderGeometry(0.18, 0.18, 1.5, 12); 
            const coneGeo = new THREE.ConeGeometry(0.45, 0.9, 4); 
            const flameGeo = createFlameGeometry();
            const bowGeo = createBowGeometry();

            const maxCount = CONFIG.count; 
            // 0-2: ÁêÉ
            shapes.meshes.push(new THREE.InstancedMesh(sphereGeo, matPearl, maxCount)); // 0: ÁôΩÁêÉ
            shapes.meshes.push(new THREE.InstancedMesh(sphereGeo, matPink, maxCount));  // 1: Á≤âÁêÉ
            shapes.meshes.push(new THREE.InstancedMesh(sphereGeo, matFlame, maxCount)); // 2: ÁÅ´ÁÑ∞ÁêÉ
            // 3-6: Ë£ÖÈ•∞
            shapes.meshes.push(new THREE.InstancedMesh(boxGeo, matGold, maxCount));     // 3: ÈáëÊñπ
            shapes.meshes.push(new THREE.InstancedMesh(candyGeo, matGold, maxCount));   // 4: ÈáëÊ£ç
            shapes.meshes.push(new THREE.InstancedMesh(coneGeo, matGold, maxCount));    // 5: ÈáëÈî•
            shapes.meshes.push(new THREE.InstancedMesh(bowGeo, matPearl, maxCount));    // 6: ÁôΩËù¥Ëù∂Áªì

            shapes.meshes.forEach(m => {
                m.receiveShadow = true; m.castShadow = true;
                m.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                mainGroup.add(m);
            });
        }

        function generateShapes() {
            const typeCounts = [0, 0, 0, 0, 0, 0, 0];
            let idx = 0;

            // 1. Â∫ïÂ±Ç (ÁèçÁè†ÁôΩ) - ÂÆΩÁüÆÔºåÊùæÊï£
            const bottomCount = Math.floor(CONFIG.count * 0.55);
            const bottomRadius = 9;
            const bottomHeight = 5;
            const bottomY = -5;

            for(; idx < bottomCount; idx++) {
                const angle = Math.random() * Math.PI * 2;
                // Â¢ûÂä†ÂçäÂæÑÈöèÊú∫ÊÄßÔºåÂà∂ÈÄ†ÊùæÊï£ÊÑü
                const r = bottomRadius * Math.sqrt(Math.random()) + (Math.random()-0.5) * 2.0; 
                const y = bottomY + Math.random() * bottomHeight + (Math.random()-0.5) * 1.5;

                particleData.cakePos[idx*3] = r * Math.cos(angle);
                particleData.cakePos[idx*3+1] = y;
                particleData.cakePos[idx*3+2] = r * Math.sin(angle);
                particleData.type[idx] = 0; 

                const rnd = Math.random();
                let shapeType = 0;
                if(rnd < 0.65) shapeType = 0; // 65% ÁôΩÁêÉ
                else if (rnd < 0.85) shapeType = 6; // 20% Ëù¥Ëù∂Áªì (ÊòæÁúº)
                else if (rnd < 0.92) shapeType = 3; // 7% ÈáëÊñπ
                else shapeType = 5; // 8% ÈáëÈî•
                
                particleData.shapeType[idx] = shapeType;
                assignMeshMapping(idx, shapeType, typeCounts);
                calculateScatterPos(idx);
            }

            // 2. È°∂Â±Ç (Â∞ëÂ•≥Á≤â) - Á™ÑÈ´ò
            const topCount = Math.floor(CONFIG.count * 0.35);
            const topRadius = 6;
            const topHeight = 6;
            const topY = bottomY + bottomHeight;

            for(let k=0; k < topCount; k++) {
                const angle = Math.random() * Math.PI * 2;
                const r = topRadius * Math.sqrt(Math.random()) + (Math.random()-0.5) * 1.5;
                const y = topY + Math.random() * topHeight + (Math.random()-0.5) * 1.0;

                particleData.cakePos[idx*3] = r * Math.cos(angle);
                particleData.cakePos[idx*3+1] = y;
                particleData.cakePos[idx*3+2] = r * Math.sin(angle);
                particleData.type[idx] = 0; 

                const rnd = Math.random();
                let shapeType = rnd < 0.85 ? 1 : 4; // 85% Á≤âÁêÉ, 15% ÈáëÊ£ç
                
                particleData.shapeType[idx] = shapeType;
                assignMeshMapping(idx, shapeType, typeCounts);
                calculateScatterPos(idx);
                idx++;
            }

            // 3. Ëú°ÁÉõ
            const candleCount = CONFIG.count - idx;
            const candleY = topY + topHeight;
            const numCandles = 6;
            
            for(let c=0; c<numCandles; c++) {
                const angle = (c / numCandles) * Math.PI * 2;
                const r = topRadius * 0.65;
                const cx = r * Math.cos(angle);
                const cz = r * Math.sin(angle);

                const parts = Math.floor(candleCount / numCandles);
                for(let p=0; p<parts; p++) {
                    if(idx >= CONFIG.count) break;
                    calculateScatterPos(idx);

                    if(p === 0) { // ÁÅ´ÁÑ∞ (Shape 2)
                        particleData.cakePos[idx*3]=cx; particleData.cakePos[idx*3+1]=candleY+1.5; particleData.cakePos[idx*3+2]=cz;
                        particleData.type[idx] = 2; 
                        particleData.shapeType[idx] = 2; // Flame Mesh
                        assignMeshMapping(idx, 2, typeCounts);
                    } else { // ÁÉõÂè∞ (Shape 4)
                        particleData.cakePos[idx*3]=cx + (Math.random()-0.5)*0.3; 
                        particleData.cakePos[idx*3+1]=candleY + Math.random()*1.2; 
                        particleData.cakePos[idx*3+2]=cz + (Math.random()-0.5)*0.3;
                        particleData.type[idx] = 1; 
                        particleData.shapeType[idx] = 4; // Candy Mesh
                        assignMeshMapping(idx, 4, typeCounts);
                    }
                    idx++;
                }
            }

            // ÊñáÂ≠ó
            const cvs = document.createElement('canvas'); cvs.width=800; cvs.height=200; 
            const ctx = cvs.getContext('2d'); ctx.font='900 80px "Times New Roman"'; ctx.fillStyle='white'; ctx.textAlign='center'; 
            ctx.fillText('HAPPY BIRTHDAY', 400, 120);
            const data = ctx.getImageData(0,0,800,200).data; const valid = [];
            // 777‰∏™Á≤íÂ≠êÔºåÈááÊ†∑Á®ÄÁñè
            for(let y=0; y<200; y+=6) for(let x=0; x<800; x+=6) if(data[(y*800+x)*4]>128) valid.push({x:(x-400)*0.13, y:(100-y)*0.13+8});
            
            for(let i=0; i<CONFIG.count; i++) {
                const p = valid[i%valid.length];
                particleData.textPos[i*3] = p.x; particleData.textPos[i*3+1] = p.y; particleData.textPos[i*3+2] = (Math.random()-0.5)*3;
                particleData.currentRot[i*3] = Math.random()*Math.PI; particleData.currentRot[i*3+1] = Math.random()*Math.PI; particleData.currentRot[i*3+2] = Math.random()*Math.PI;
                particleData.noise[i] = Math.random()*100;
            }

            shapes.meshes.forEach(m => { m.instanceMatrix.needsUpdate = true; });
        }

        function calculateScatterPos(idx) {
            const scatterRadius = 35; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const sr = Math.cbrt(Math.random()) * scatterRadius; 
            particleData.scatterPos[idx*3] = sr * Math.sin(phi) * Math.cos(theta);
            particleData.scatterPos[idx*3+1] = sr * Math.sin(phi) * Math.sin(theta);
            particleData.scatterPos[idx*3+2] = sr * Math.cos(phi);
        }

        function assignMeshMapping(particleIdx, shapeType, typeCounts) {
            if (particleIdx >= CONFIG.count) return;
            particleData.meshMapping[particleIdx] = { meshIdx: shapeType, instanceIdx: typeCounts[shapeType]++ };
        }

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", outputFaceBlendshapes: true
            });
            video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            return new Promise(resolve => video.onloadeddata = resolve);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            if (state.aiReady && video.readyState >= 2) {
                const pc = document.getElementById('webcam-preview');
                pc.getContext('2d').drawImage(video, 0, 0, pc.width, pc.height);
                const t = performance.now();

                const face = faceLandmarker.detectForVideo(video, t);
                const hand = handLandmarker.detectForVideo(video, t);

                if (state.step === 0) {
                    if (face.faceBlendshapes.length > 0) {
                        const cats = face.faceBlendshapes[0].categories;
                        const pucker = cats.find(c => c.categoryName === 'mouthPucker').score;
                        const funnel = cats.find(c => c.categoryName === 'mouthFunnel').score;
                        // Ê∑∑ÂêàÊ£ÄÊµãÔºåÈôç‰ΩéÈòàÂÄº
                        if (pucker > CONFIG.blowThreshold || funnel > CONFIG.blowThreshold || (pucker+funnel)>0.4) { 
                            puckerFrames++; if (puckerFrames > 5) triggerBlowSequence(); 
                        } else {
                            puckerFrames = 0;
                        }
                    }
                    if (hand.landmarks.length > 0) {
                        const lm = hand.landmarks[0];
                        const spread = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                        if (spread > CONFIG.spreadThreshold) state.step = 3; 
                    }
                }

                if (hand.landmarks.length > 0) {
                    const lm = hand.landmarks[0];
                    const spread = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    if (state.step !== 2) state.rotation = (lm[9].x - 0.5) * 5; 
                    
                    if (state.step >= 2) { 
                        if (spread > CONFIG.spreadThreshold) state.step = 3;
                        else if (state.step === 3 && spread <= CONFIG.spreadThreshold) resetToCake();
                    }
                }
            }

            const pos = particleData.currentPos;
            const rot = particleData.currentRot;
            
            let target;
            if (state.step === 3) target = particleData.scatterPos; 
            else if (state.step === 2) target = particleData.textPos;
            else target = particleData.cakePos;

            for(let i=0; i<CONFIG.count; i++) {
                const i3 = i*3;
                let scale = 1.0;

                if (state.step === 0 && particleData.type[i] === 2) { // ÁÅ´ÁÑ∞ÂæÆÂä®
                    pos[i3] += Math.sin(time*12 + particleData.noise[i])*0.03;
                    pos[i3+1] += Math.cos(time*8 + particleData.noise[i])*0.02;
                }
                
                if (state.step === 1 && particleData.type[i] === 2) { 
                    const elapsed = (performance.now() - state.blowStartTime) / 1600; 
                    pos[i3+1] += 0.1 * (1-elapsed); 
                    scale = Math.max(0, 1 - elapsed); 
                } else if (state.step === 1 && particleData.type[i] !== 2) {
                     pos[i3] += Math.sin(time*5+i)*0.02;
                }

                if (state.step === 3) {
                     pos[i3] += Math.sin(time + particleData.noise[i]) * 0.05;
                     pos[i3+1] += Math.cos(time * 0.9 + particleData.noise[i]) * 0.05;
                }

                if (state.step !== 1 || particleData.type[i] !== 2) { 
                    const speed = (state.step === 3) ? 0.06 : ((state.step === 0) ? 0.12 : 0.08);
                    pos[i3] += (target[i3] - pos[i3]) * speed;
                    pos[i3+1] += (target[i3+1] - pos[i3+1]) * speed;
                    pos[i3+2] += (target[i3+2] - pos[i3+2]) * speed;
                }

                const map = particleData.meshMapping[i];
                if (map && shapes.meshes[map.meshIdx]) {
                    shapes.dummy.position.set(pos[i3], pos[i3+1], pos[i3+2]);
                    
                    // ÁÅ´ÁÑ∞‰øùÊåÅÁõ¥Á´ã (ÂÖ≥ÈîÆ‰øÆÂ§ç)
                    if (particleData.shapeType[i] === 2) {
                        shapes.dummy.rotation.set(0, rot[i3+1] + time, 0); 
                    } else {
                        shapes.dummy.rotation.set(rot[i3], rot[i3+1], rot[i3+2]);
                    }
                    
                    if (particleData.shapeType[i] === 2) scale *= 1.6; // ÁÅ´ÁÑ∞Êõ¥Â§ß
                    if (particleData.shapeType[i] === 3 || particleData.shapeType[i] === 5) scale *= 1.3; 
                    if (particleData.shapeType[i] === 6) scale *= 2.2; // Ëù¥Ëù∂ÁªìÊòæËëóÊîæÂ§ß

                    if(state.step === 3) scale *= 0.9;
                    if(state.step === 2) scale *= 0.7;

                    shapes.dummy.scale.set(scale, scale, scale);
                    shapes.dummy.updateMatrix();
                    shapes.meshes[map.meshIdx].setMatrixAt(map.instanceIdx, shapes.dummy.matrix);
                }
            }

            shapes.meshes.forEach(m => m.instanceMatrix.needsUpdate = true);
            
            let targetRotation = state.step === 2 ? 0 : state.rotation;
            if(mainGroup) mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, targetRotation, 0.05);
            
            if(mainGroup && !state.aiReady && state.step === 0) mainGroup.rotation.y += 0.003; 

            composer.render();
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); 
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
