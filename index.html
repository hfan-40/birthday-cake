<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rose Gold Final Celebration</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050202; font-family: 'Times New Roman', serif; }
        
        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; padding-top: 5vh; }
        
        h1 {
            color: #E6C2BF; /* æŸ”å’Œç«ç‘°ç²‰ */
            font-size: 2.5rem; letter-spacing: 0.5rem; text-transform: uppercase;
            text-shadow: 0 0 30px rgba(183, 110, 121, 0.6); margin-bottom: 10px; 
            opacity: 0; animation: fadeIn 2s forwards 1s;
        }

        .hint {
            color: #d4af37; font-size: 0.9rem; border: 1px solid rgba(212, 175, 55, 0.3);
            padding: 8px 25px; border-radius: 30px; background: rgba(20, 10, 10, 0.6);
            backdrop-filter: blur(5px); opacity: 0; animation: fadeIn 2s forwards 2s;
            display: flex; gap: 15px; align-items: center;
        }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-dot { width: 8px; height: 8px; background: #333; border-radius: 50%; display: inline-block; transition: background 0.3s; }
        .status-active { background: #0f0; box-shadow: 0 0 10px #0f0; }

        #loader { position: fixed; inset: 0; background: #000; z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.8s ease; }
        .circle { width: 60px; height: 60px; border: 2px solid rgba(183, 110, 121, 0.2); border-top: 2px solid #B76E79; border-radius: 50%; animation: spin 1s infinite linear; }
        .log-text { color: #B76E79; margin-top: 20px; font-size: 12px; letter-spacing: 1px; font-family: monospace; }

        #webcam-preview { 
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
            border: 1px solid #B76E79; border-radius: 8px; z-index: 20; 
            transform: scaleX(-1); opacity: 0.7;
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { to { opacity: 1; } }
    </style>
</head>
<body>

    <div id="loader">
        <div class="circle"></div>
        <div class="log-text" id="log">INITIALIZING...</div>
    </div>

    <div id="ui-layer">
        <h1 id="title">Grand Celebration</h1>
        <div class="hint">
            <span id="ai-status" class="status-dot"></span>
            <span id="guide">ç­‰å¾… AI è§†è§‰å¼•æ“...</span>
        </div>
    </div>

    <video id="webcam" autoplay playsinline style="display:none;"></video>
    <canvas id="webcam-preview"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker } from '@mediapipe/tasks-vision';

        // --- é…ç½®ä¸­å¿ƒ ---
        const CONFIG = {
            count: 4500, // ç²’å­æ•°é‡
            colors: {
                roseGold: new THREE.Color(0xB76E79), // ç«ç‘°é‡‘
                champagne: new THREE.Color(0xF7E7CE), // é¦™æ§Ÿ
                copper: new THREE.Color(0xCD7F32),    // é“œè‰²
                flame: new THREE.Color(0xFF5500),     // ç«ç„°
                smoke: new THREE.Color(0x333333)      // çƒŸé›¾
            },
            blowThreshold: 0.45 // å˜Ÿå˜´é˜ˆå€¼ (è¶Šå°è¶Šå®¹æ˜“è§¦å‘)
        };

        let scene, camera, renderer, composer, particles;
        let handLandmarker, faceLandmarker, video;
        let puckerFrames = 0; // é˜²æŠ–è®¡æ•°
        let clock = new THREE.Clock();
        
        // æ ¸å¿ƒçŠ¶æ€æœº
        let state = {
            step: 0, // 0:è›‹ç³•ç‚¹äº®, 1:å¹æ°”ç†„ç­ä¸­, 2:æ–‡å­—å±•ç¤º, 3:æ‰‹åŠ¿æ•£å¼€
            rotation: 0,
            aiReady: false
        };

        const particleData = {
            cake: new Float32Array(CONFIG.count * 3),
            text: new Float32Array(CONFIG.count * 3),
            current: new Float32Array(CONFIG.count * 3),
            type: new Uint8Array(CONFIG.count), // 0:Body, 1:Wick, 2:Flame
            noise: new Float32Array(CONFIG.count)
        };

        const logger = document.getElementById('log');

        async function init() {
            try {
                logger.innerText = "CREATING 3D WORLD...";
                initThree();
                generateShapes();
                
                logger.innerText = "CONNECTING AI VISION...";
                await initAI();
                
                state.aiReady = true;
                document.getElementById('ai-status').classList.add('status-active');
                document.getElementById('guide').innerText = "ğŸ˜— è¯·å˜Ÿå˜´å¹ç­èœ¡çƒ›";
                
            } catch (err) {
                console.error(err);
                logger.innerText = "AI FAILED. CLICK MODE.";
                state.aiReady = false;
                setupMouseMode();
            } finally {
                setTimeout(() => document.getElementById('loader').style.opacity = 0, 500);
                setTimeout(() => document.getElementById('loader').remove(), 1500);
                animate();
            }
        }

        function setupMouseMode() {
            document.getElementById('guide').innerText = "ğŸ–±ï¸ ç‚¹å‡»å±å¹•å¹ç­èœ¡çƒ›";
            window.addEventListener('click', triggerBlowSequence);
            window.addEventListener('mousemove', e => state.rotation = (e.clientX/window.innerWidth-0.5)*4);
        }

        // --- æ ¸å¿ƒé€»è¾‘ï¼šå¹ç­æµç¨‹ ---
        function triggerBlowSequence() {
            if (state.step === 0) { // ä»…åœ¨è›‹ç³•ç‚¹äº®æ—¶è§¦å‘
                state.step = 1; // è¿›å…¥ç†„ç­çŠ¶æ€
                
                // 1. å˜è‰²ï¼šç«ç„°å˜çƒŸé›¾
                const colors = particles.geometry.attributes.color.array;
                for(let i=0; i<CONFIG.count; i++) {
                    if (particleData.type[i] === 2) {
                        colors[i*3] = CONFIG.colors.smoke.r;
                        colors[i*3+1] = CONFIG.colors.smoke.g;
                        colors[i*3+2] = CONFIG.colors.smoke.b;
                    }
                }
                particles.geometry.attributes.color.needsUpdate = true;

                // 2. å»¶è¿Ÿåå˜èº«æ–‡å­—
                setTimeout(() => {
                    state.step = 2; // æ–‡å­—çŠ¶æ€
                    updateTitle("Happy Birthday!");
                    document.getElementById('guide').innerText = "ğŸ– å¼ å¼€æ‰‹æŒ: æ•£æ”¾ç¥ç¦";
                }, 1500);
            }
        }

        function updateTitle(text) {
            const t = document.getElementById('title');
            t.style.opacity = 0;
            setTimeout(() => {
                t.innerText = text;
                t.style.textShadow = "0 0 40px #FFD700";
                t.style.opacity = 1;
            }, 500);
        }

        // --- 3D åˆå§‹åŒ– ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050202, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 45);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // ç«ç‘°é‡‘è¾‰å…‰å‚æ•°
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);

            // ç²’å­ç³»ç»Ÿ
            const geo = new THREE.BufferGeometry();
            const colors = [];
            const sizes = [];
            
            for(let i=0; i<CONFIG.count; i++) {
                particleData.current[i*3] = (Math.random()-0.5)*100;
                particleData.current[i*3+1] = (Math.random()-0.5)*100;
                particleData.current[i*3+2] = (Math.random()-0.5)*100;
                particleData.noise[i] = Math.random() * 100;

                colors.push(0,0,0); // åˆå§‹é¢œè‰²å°†åœ¨ generateShapes ä¸­è®¾ç½®
                sizes.push(0.15);
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(particleData.current, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const mat = new THREE.PointsMaterial({
                vertexColors: true, transparent: true, opacity: 0.9,
                blending: THREE.AdditiveBlending, sizeAttenuation: true, depthWrite: false
            });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        function generateShapes() {
            const colors = particles.geometry.attributes.color.array;
            const sizes = particles.geometry.attributes.size.array;
            
            let idx = 0;
            
            // 1. è›‹ç³•ä½“ (ç«ç‘°é‡‘/é¦™æ§Ÿ/é“œè‰² æ··åˆ)
            const bodyEnd = Math.floor(CONFIG.count * 0.85);
            for(; idx < bodyEnd; idx++) {
                const angle = Math.random() * Math.PI * 2;
                let r, y, c;
                
                if(Math.random() > 0.4) { // åº•å±‚
                    r = 8 + Math.random() * 1.5; y = Math.random() * 6 - 4;
                } else { // é¡¶å±‚
                    r = 5 + Math.random() * 1.2; y = Math.random() * 5 + 2;
                }

                // ç«ç‘°é‡‘æ··è‰²é€»è¾‘
                const rnd = Math.random();
                if (rnd > 0.6) c = CONFIG.colors.roseGold;
                else if (rnd > 0.3) c = CONFIG.colors.copper;
                else c = CONFIG.colors.champagne;

                particleData.cake[idx*3] = Math.cos(angle)*r;
                particleData.cake[idx*3+1] = y;
                particleData.cake[idx*3+2] = Math.sin(angle)*r;
                particleData.type[idx] = 0;

                colors[idx*3] = c.r; colors[idx*3+1] = c.g; colors[idx*3+2] = c.b;
                sizes[idx] = 0.15 + Math.random() * 0.1;
            }

            // 2. èœ¡çƒ›ä¸ç«ç„° (6æ ¹)
            const candles = 6;
            for(let c=0; c<candles; c++) {
                const angle = (c/candles) * Math.PI * 2;
                const cx = Math.cos(angle)*3.5;
                const cz = Math.sin(angle)*3.5;
                const cy = 7;
                
                const pPerCandle = Math.floor((CONFIG.count - idx)/candles);
                for(let k=0; k<pPerCandle; k++) {
                    const ii = idx + k;
                    if(ii >= CONFIG.count) break;

                    if(k < pPerCandle * 0.6) { // çƒ›èŠ¯
                        particleData.cake[ii*3] = cx + (Math.random()-0.5)*0.2;
                        particleData.cake[ii*3+1] = cy + Math.random()*2;
                        particleData.cake[ii*3+2] = cz + (Math.random()-0.5)*0.2;
                        particleData.type[ii] = 1;
                        colors[ii*3] = 1; colors[ii*3+1] = 1; colors[ii*3+2] = 1; // ç™½
                    } else { // ç«ç„°
                        particleData.cake[ii*3] = cx + (Math.random()-0.5)*0.4;
                        particleData.cake[ii*3+1] = cy + 2.2 + Math.random();
                        particleData.cake[ii*3+2] = cz + (Math.random()-0.5)*0.4;
                        particleData.type[ii] = 2;
                        colors[ii*3] = CONFIG.colors.flame.r; 
                        colors[ii*3+1] = CONFIG.colors.flame.g; 
                        colors[ii*3+2] = CONFIG.colors.flame.b;
                        sizes[ii] = 0.25;
                    }
                }
                idx += pPerCandle;
            }

            // æ–‡å­—å½¢çŠ¶
            const cvs = document.createElement('canvas');
            cvs.width=600; cvs.height=150;
            const ctx = cvs.getContext('2d');
            ctx.font='900 60px "Times New Roman"';
            ctx.fillStyle='white'; ctx.textAlign='center';
            ctx.fillText('HAPPY BIRTHDAY', 300, 80);
            const data = ctx.getImageData(0,0,600,150).data;
            const valid = [];
            for(let y=0; y<150; y+=3) for(let x=0; x<600; x+=3) 
                if(data[(y*600+x)*4]>128) valid.push({x:(x-300)*0.14, y:(75-y)*0.14+6});
            
            for(let i=0; i<CONFIG.count; i++) {
                const p = valid[i%valid.length];
                particleData.text[i*3] = p.x;
                particleData.text[i*3+1] = p.y;
                particleData.text[i*3+2] = (Math.random()-0.5)*2;
            }

            particles.geometry.attributes.color.needsUpdate = true;
            particles.geometry.attributes.size.needsUpdate = true;
        }

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", outputFaceBlendshapes: true
            });
            video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            return new Promise(resolve => {
                video.onloadeddata = () => {
                    const pc = document.getElementById('webcam-preview');
                    pc.width = video.videoWidth; pc.height = video.videoHeight;
                    resolve();
                };
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            // --- AI äº¤äº’é€»è¾‘ ---
            if (state.aiReady && video.readyState >= 2) {
                const pc = document.getElementById('webcam-preview');
                pc.getContext('2d').drawImage(video, 0, 0, pc.width, pc.height);
                const t = performance.now();

                // 1. å¹æ°”æ£€æµ‹ (å˜Ÿå˜´)
                const face = faceLandmarker.detectForVideo(video, t);
                if (face.faceBlendshapes.length > 0 && state.step === 0) {
                    const pucker = face.faceBlendshapes[0].categories.find(c => c.categoryName === 'mouthPucker').score;
                    if (pucker > CONFIG.blowThreshold) {
                        puckerFrames++;
                        if (puckerFrames > 10) triggerBlowSequence(); // æŒç»­è§¦å‘
                    } else {
                        puckerFrames = 0;
                    }
                }

                // 2. æ‰‹åŠ¿æ£€æµ‹ (æ•£å¼€)
                const hand = handLandmarker.detectForVideo(video, t);
                if (hand.landmarks.length > 0) {
                    const lm = hand.landmarks[0];
                    const spread = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    state.rotation = (lm[9].x - 0.5) * 4;

                    // åªæœ‰åœ¨æ–‡å­—å±•ç¤ºé˜¶æ®µ(step 2) æˆ– æ•£å¼€é˜¶æ®µ(step 3) æ‰å…è®¸æ•£å¼€
                    if (state.step >= 2) {
                        if (spread > 0.45) state.step = 3; // å¼ºåˆ¶æ•£å¼€
                        else state.step = 2; // å›å½’æ–‡å­—
                    }
                }
            }

            // --- ç²’å­ç‰©ç†æ¸²æŸ“ ---
            const pos = particles.geometry.attributes.position.array;
            let target;

            // ç›®æ ‡é€‰æ‹©
            if (state.step === 0 || state.step === 1) target = particleData.cake; // è›‹ç³• & ç†„ç­ä¸­
            else target = particleData.text; // æ–‡å­—

            for(let i=0; i<CONFIG.count; i++) {
                const i3 = i*3;
                
                // ç‰¹æ®ŠçŠ¶æ€å¤„ç†
                if (state.step === 0 && particleData.type[i] === 2) {
                    // ç«ç„°è·³åŠ¨
                    pos[i3] += (Math.random()-0.5)*0.05;
                    particleData.cake[i3+1] += Math.sin(time*10+i)*0.02; 
                }
                
                if (state.step === 1 && particleData.type[i] === 2) {
                    // çƒŸé›¾ä¸Šé£˜
                    pos[i3+1] += 0.08; 
                    pos[i3] += Math.sin(time*2+i)*0.02;
                    continue; // çƒŸé›¾ä¸èµ° lerp
                }

                if (state.step === 3) {
                    // æ•£å¼€ (Scatter)
                    pos[i3] += Math.sin(time + particleData.noise[i]) * 0.08;
                    pos[i3+1] += Math.cos(time + particleData.noise[i]) * 0.08;
                    pos[i3+2] += Math.sin(time*0.5 + particleData.noise[i]) * 0.08;
                } else {
                    // èšåˆ (Lerp)
                    const speed = (state.step >= 2) ? 0.06 : 0.1;
                    pos[i3] += (target[i3] - pos[i3]) * speed;
                    pos[i3+1] += (target[i3+1] - pos[i3+1]) * speed;
                    pos[i3+2] += (target[i3+2] - pos[i3+2]) * speed;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, state.rotation, 0.05);
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
